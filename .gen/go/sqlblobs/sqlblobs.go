// Code generated by thriftrw v1.29.2. DO NOT EDIT.
// @generated

package sqlblobs

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	fmt "fmt"
	math "math"
	strconv "strconv"
	strings "strings"

	multierr "go.uber.org/multierr"
	stream "go.uber.org/thriftrw/protocol/stream"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"

	shared "github.com/uber/cadence/.gen/go/shared"
)

type ActivityInfo struct {
	Version                       *int64   `json:"version,omitempty"`
	ScheduledEventBatchID         *int64   `json:"scheduledEventBatchID,omitempty"`
	ScheduledEvent                []byte   `json:"scheduledEvent,omitempty"`
	ScheduledEventEncoding        *string  `json:"scheduledEventEncoding,omitempty"`
	ScheduledTimeNanos            *int64   `json:"scheduledTimeNanos,omitempty"`
	StartedID                     *int64   `json:"startedID,omitempty"`
	StartedEvent                  []byte   `json:"startedEvent,omitempty"`
	StartedEventEncoding          *string  `json:"startedEventEncoding,omitempty"`
	StartedTimeNanos              *int64   `json:"startedTimeNanos,omitempty"`
	ActivityID                    *string  `json:"activityID,omitempty"`
	RequestID                     *string  `json:"requestID,omitempty"`
	ScheduleToStartTimeoutSeconds *int32   `json:"scheduleToStartTimeoutSeconds,omitempty"`
	ScheduleToCloseTimeoutSeconds *int32   `json:"scheduleToCloseTimeoutSeconds,omitempty"`
	StartToCloseTimeoutSeconds    *int32   `json:"startToCloseTimeoutSeconds,omitempty"`
	HeartbeatTimeoutSeconds       *int32   `json:"heartbeatTimeoutSeconds,omitempty"`
	CancelRequested               *bool    `json:"cancelRequested,omitempty"`
	CancelRequestID               *int64   `json:"cancelRequestID,omitempty"`
	TimerTaskStatus               *int32   `json:"timerTaskStatus,omitempty"`
	Attempt                       *int32   `json:"attempt,omitempty"`
	TaskList                      *string  `json:"taskList,omitempty"`
	StartedIdentity               *string  `json:"startedIdentity,omitempty"`
	HasRetryPolicy                *bool    `json:"hasRetryPolicy,omitempty"`
	RetryInitialIntervalSeconds   *int32   `json:"retryInitialIntervalSeconds,omitempty"`
	RetryMaximumIntervalSeconds   *int32   `json:"retryMaximumIntervalSeconds,omitempty"`
	RetryMaximumAttempts          *int32   `json:"retryMaximumAttempts,omitempty"`
	RetryExpirationTimeNanos      *int64   `json:"retryExpirationTimeNanos,omitempty"`
	RetryBackoffCoefficient       *float64 `json:"retryBackoffCoefficient,omitempty"`
	RetryNonRetryableErrors       []string `json:"retryNonRetryableErrors,omitempty"`
	RetryLastFailureReason        *string  `json:"retryLastFailureReason,omitempty"`
	RetryLastWorkerIdentity       *string  `json:"retryLastWorkerIdentity,omitempty"`
	RetryLastFailureDetails       []byte   `json:"retryLastFailureDetails,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a ActivityInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *ActivityInfo) ToWire() (wire.Value, error) {
	var (
		fields [31]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ScheduledEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.ScheduledEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ScheduledEvent != nil {
		w, err = wire.NewValueBinary(v.ScheduledEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.ScheduledEventEncoding != nil {
		w, err = wire.NewValueString(*(v.ScheduledEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.ScheduledTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.ScheduledTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.StartedID != nil {
		w, err = wire.NewValueI64(*(v.StartedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.StartedEvent != nil {
		w, err = wire.NewValueBinary(v.StartedEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.StartedEventEncoding != nil {
		w, err = wire.NewValueString(*(v.StartedEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.StartedTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.StartedTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.RequestID != nil {
		w, err = wire.NewValueString(*(v.RequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.ScheduleToStartTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.ScheduleToCloseTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.ScheduleToCloseTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.StartToCloseTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.StartToCloseTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 36, Value: w}
		i++
	}
	if v.HeartbeatTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.HeartbeatTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}
	if v.CancelRequested != nil {
		w, err = wire.NewValueBool(*(v.CancelRequested)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.CancelRequestID != nil {
		w, err = wire.NewValueI64(*(v.CancelRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 42, Value: w}
		i++
	}
	if v.TimerTaskStatus != nil {
		w, err = wire.NewValueI32(*(v.TimerTaskStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 44, Value: w}
		i++
	}
	if v.Attempt != nil {
		w, err = wire.NewValueI32(*(v.Attempt)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 46, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = wire.NewValueString(*(v.TaskList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 48, Value: w}
		i++
	}
	if v.StartedIdentity != nil {
		w, err = wire.NewValueString(*(v.StartedIdentity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.HasRetryPolicy != nil {
		w, err = wire.NewValueBool(*(v.HasRetryPolicy)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 52, Value: w}
		i++
	}
	if v.RetryInitialIntervalSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryInitialIntervalSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 54, Value: w}
		i++
	}
	if v.RetryMaximumIntervalSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryMaximumIntervalSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 56, Value: w}
		i++
	}
	if v.RetryMaximumAttempts != nil {
		w, err = wire.NewValueI32(*(v.RetryMaximumAttempts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 58, Value: w}
		i++
	}
	if v.RetryExpirationTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.RetryExpirationTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.RetryBackoffCoefficient != nil {
		w, err = wire.NewValueDouble(*(v.RetryBackoffCoefficient)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 62, Value: w}
		i++
	}
	if v.RetryNonRetryableErrors != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.RetryNonRetryableErrors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 64, Value: w}
		i++
	}
	if v.RetryLastFailureReason != nil {
		w, err = wire.NewValueString(*(v.RetryLastFailureReason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 66, Value: w}
		i++
	}
	if v.RetryLastWorkerIdentity != nil {
		w, err = wire.NewValueString(*(v.RetryLastWorkerIdentity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 68, Value: w}
		i++
	}
	if v.RetryLastFailureDetails != nil {
		w, err = wire.NewValueBinary(v.RetryLastFailureDetails), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ActivityInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ActivityInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v ActivityInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *ActivityInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduledEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				v.ScheduledEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ScheduledEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduledTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedID = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				v.StartedEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RequestID = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ScheduleToStartTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ScheduleToCloseTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 36:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.StartToCloseTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.HeartbeatTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CancelRequested = &x
				if err != nil {
					return err
				}

			}
		case 42:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CancelRequestID = &x
				if err != nil {
					return err
				}

			}
		case 44:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.TimerTaskStatus = &x
				if err != nil {
					return err
				}

			}
		case 46:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Attempt = &x
				if err != nil {
					return err
				}

			}
		case 48:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TaskList = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedIdentity = &x
				if err != nil {
					return err
				}

			}
		case 52:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.HasRetryPolicy = &x
				if err != nil {
					return err
				}

			}
		case 54:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryInitialIntervalSeconds = &x
				if err != nil {
					return err
				}

			}
		case 56:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryMaximumIntervalSeconds = &x
				if err != nil {
					return err
				}

			}
		case 58:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryMaximumAttempts = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RetryExpirationTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 62:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.RetryBackoffCoefficient = &x
				if err != nil {
					return err
				}

			}
		case 64:
			if field.Value.Type() == wire.TList {
				v.RetryNonRetryableErrors, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 66:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RetryLastFailureReason = &x
				if err != nil {
					return err
				}

			}
		case 68:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RetryLastWorkerIdentity = &x
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TBinary {
				v.RetryLastFailureDetails, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_String_Encode(val []string, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TBinary,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for _, v := range val {
		if err := sw.WriteString(v); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a ActivityInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ActivityInfo struct could not be encoded.
func (v *ActivityInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduledEventBatchID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ScheduledEventBatchID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduledEvent != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.ScheduledEvent); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduledEventEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ScheduledEventEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduledTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ScheduledTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StartedID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedEvent != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.StartedEvent); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedEventEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.StartedEventEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 26, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StartedTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ActivityID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 28, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ActivityID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 30, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.RequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduleToStartTimeoutSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 32, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ScheduleToStartTimeoutSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduleToCloseTimeoutSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 34, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ScheduleToCloseTimeoutSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartToCloseTimeoutSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 36, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.StartToCloseTimeoutSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.HeartbeatTimeoutSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 38, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.HeartbeatTimeoutSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CancelRequested != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 40, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.CancelRequested)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CancelRequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 42, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.CancelRequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TimerTaskStatus != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 44, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.TimerTaskStatus)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Attempt != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 46, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Attempt)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskList != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 48, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.TaskList)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedIdentity != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 50, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.StartedIdentity)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.HasRetryPolicy != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 52, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.HasRetryPolicy)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryInitialIntervalSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 54, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryInitialIntervalSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryMaximumIntervalSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 56, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryMaximumIntervalSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryMaximumAttempts != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 58, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryMaximumAttempts)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryExpirationTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 60, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.RetryExpirationTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryBackoffCoefficient != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 62, Type: wire.TDouble}); err != nil {
			return err
		}
		if err := sw.WriteDouble(*(v.RetryBackoffCoefficient)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryNonRetryableErrors != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 64, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.RetryNonRetryableErrors, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryLastFailureReason != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 66, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.RetryLastFailureReason)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryLastWorkerIdentity != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 68, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.RetryLastWorkerIdentity)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryLastFailureDetails != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 70, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.RetryLastFailureDetails); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _List_String_Decode(sr stream.Reader) ([]string, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TBinary {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]string, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := sr.ReadString()
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a ActivityInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ActivityInfo struct could not be generated from the wire
// representation.
func (v *ActivityInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ScheduledEventBatchID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			v.ScheduledEvent, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ScheduledEventEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ScheduledTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StartedID = &x
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TBinary:
			v.StartedEvent, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.StartedEventEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 26 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StartedTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 28 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ActivityID = &x
			if err != nil {
				return err
			}

		case fh.ID == 30 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.RequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 32 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ScheduleToStartTimeoutSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 34 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ScheduleToCloseTimeoutSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 36 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.StartToCloseTimeoutSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 38 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.HeartbeatTimeoutSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 40 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.CancelRequested = &x
			if err != nil {
				return err
			}

		case fh.ID == 42 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.CancelRequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 44 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.TimerTaskStatus = &x
			if err != nil {
				return err
			}

		case fh.ID == 46 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Attempt = &x
			if err != nil {
				return err
			}

		case fh.ID == 48 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.TaskList = &x
			if err != nil {
				return err
			}

		case fh.ID == 50 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.StartedIdentity = &x
			if err != nil {
				return err
			}

		case fh.ID == 52 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.HasRetryPolicy = &x
			if err != nil {
				return err
			}

		case fh.ID == 54 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryInitialIntervalSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 56 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryMaximumIntervalSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 58 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryMaximumAttempts = &x
			if err != nil {
				return err
			}

		case fh.ID == 60 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.RetryExpirationTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 62 && fh.Type == wire.TDouble:
			var x float64
			x, err = sr.ReadDouble()
			v.RetryBackoffCoefficient = &x
			if err != nil {
				return err
			}

		case fh.ID == 64 && fh.Type == wire.TList:
			v.RetryNonRetryableErrors, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 66 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.RetryLastFailureReason = &x
			if err != nil {
				return err
			}

		case fh.ID == 68 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.RetryLastWorkerIdentity = &x
			if err != nil {
				return err
			}

		case fh.ID == 70 && fh.Type == wire.TBinary:
			v.RetryLastFailureDetails, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ActivityInfo
// struct.
func (v *ActivityInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [31]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.ScheduledEventBatchID != nil {
		fields[i] = fmt.Sprintf("ScheduledEventBatchID: %v", *(v.ScheduledEventBatchID))
		i++
	}
	if v.ScheduledEvent != nil {
		fields[i] = fmt.Sprintf("ScheduledEvent: %v", v.ScheduledEvent)
		i++
	}
	if v.ScheduledEventEncoding != nil {
		fields[i] = fmt.Sprintf("ScheduledEventEncoding: %v", *(v.ScheduledEventEncoding))
		i++
	}
	if v.ScheduledTimeNanos != nil {
		fields[i] = fmt.Sprintf("ScheduledTimeNanos: %v", *(v.ScheduledTimeNanos))
		i++
	}
	if v.StartedID != nil {
		fields[i] = fmt.Sprintf("StartedID: %v", *(v.StartedID))
		i++
	}
	if v.StartedEvent != nil {
		fields[i] = fmt.Sprintf("StartedEvent: %v", v.StartedEvent)
		i++
	}
	if v.StartedEventEncoding != nil {
		fields[i] = fmt.Sprintf("StartedEventEncoding: %v", *(v.StartedEventEncoding))
		i++
	}
	if v.StartedTimeNanos != nil {
		fields[i] = fmt.Sprintf("StartedTimeNanos: %v", *(v.StartedTimeNanos))
		i++
	}
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.RequestID != nil {
		fields[i] = fmt.Sprintf("RequestID: %v", *(v.RequestID))
		i++
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("ScheduleToStartTimeoutSeconds: %v", *(v.ScheduleToStartTimeoutSeconds))
		i++
	}
	if v.ScheduleToCloseTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("ScheduleToCloseTimeoutSeconds: %v", *(v.ScheduleToCloseTimeoutSeconds))
		i++
	}
	if v.StartToCloseTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("StartToCloseTimeoutSeconds: %v", *(v.StartToCloseTimeoutSeconds))
		i++
	}
	if v.HeartbeatTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("HeartbeatTimeoutSeconds: %v", *(v.HeartbeatTimeoutSeconds))
		i++
	}
	if v.CancelRequested != nil {
		fields[i] = fmt.Sprintf("CancelRequested: %v", *(v.CancelRequested))
		i++
	}
	if v.CancelRequestID != nil {
		fields[i] = fmt.Sprintf("CancelRequestID: %v", *(v.CancelRequestID))
		i++
	}
	if v.TimerTaskStatus != nil {
		fields[i] = fmt.Sprintf("TimerTaskStatus: %v", *(v.TimerTaskStatus))
		i++
	}
	if v.Attempt != nil {
		fields[i] = fmt.Sprintf("Attempt: %v", *(v.Attempt))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", *(v.TaskList))
		i++
	}
	if v.StartedIdentity != nil {
		fields[i] = fmt.Sprintf("StartedIdentity: %v", *(v.StartedIdentity))
		i++
	}
	if v.HasRetryPolicy != nil {
		fields[i] = fmt.Sprintf("HasRetryPolicy: %v", *(v.HasRetryPolicy))
		i++
	}
	if v.RetryInitialIntervalSeconds != nil {
		fields[i] = fmt.Sprintf("RetryInitialIntervalSeconds: %v", *(v.RetryInitialIntervalSeconds))
		i++
	}
	if v.RetryMaximumIntervalSeconds != nil {
		fields[i] = fmt.Sprintf("RetryMaximumIntervalSeconds: %v", *(v.RetryMaximumIntervalSeconds))
		i++
	}
	if v.RetryMaximumAttempts != nil {
		fields[i] = fmt.Sprintf("RetryMaximumAttempts: %v", *(v.RetryMaximumAttempts))
		i++
	}
	if v.RetryExpirationTimeNanos != nil {
		fields[i] = fmt.Sprintf("RetryExpirationTimeNanos: %v", *(v.RetryExpirationTimeNanos))
		i++
	}
	if v.RetryBackoffCoefficient != nil {
		fields[i] = fmt.Sprintf("RetryBackoffCoefficient: %v", *(v.RetryBackoffCoefficient))
		i++
	}
	if v.RetryNonRetryableErrors != nil {
		fields[i] = fmt.Sprintf("RetryNonRetryableErrors: %v", v.RetryNonRetryableErrors)
		i++
	}
	if v.RetryLastFailureReason != nil {
		fields[i] = fmt.Sprintf("RetryLastFailureReason: %v", *(v.RetryLastFailureReason))
		i++
	}
	if v.RetryLastWorkerIdentity != nil {
		fields[i] = fmt.Sprintf("RetryLastWorkerIdentity: %v", *(v.RetryLastWorkerIdentity))
		i++
	}
	if v.RetryLastFailureDetails != nil {
		fields[i] = fmt.Sprintf("RetryLastFailureDetails: %v", v.RetryLastFailureDetails)
		i++
	}

	return fmt.Sprintf("ActivityInfo{%v}", strings.Join(fields[:i], ", "))
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ActivityInfo match the
// provided ActivityInfo.
//
// This function performs a deep comparison.
func (v *ActivityInfo) Equals(rhs *ActivityInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduledEventBatchID, rhs.ScheduledEventBatchID) {
		return false
	}
	if !((v.ScheduledEvent == nil && rhs.ScheduledEvent == nil) || (v.ScheduledEvent != nil && rhs.ScheduledEvent != nil && bytes.Equal(v.ScheduledEvent, rhs.ScheduledEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.ScheduledEventEncoding, rhs.ScheduledEventEncoding) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduledTimeNanos, rhs.ScheduledTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedID, rhs.StartedID) {
		return false
	}
	if !((v.StartedEvent == nil && rhs.StartedEvent == nil) || (v.StartedEvent != nil && rhs.StartedEvent != nil && bytes.Equal(v.StartedEvent, rhs.StartedEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.StartedEventEncoding, rhs.StartedEventEncoding) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedTimeNanos, rhs.StartedTimeNanos) {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !_String_EqualsPtr(v.RequestID, rhs.RequestID) {
		return false
	}
	if !_I32_EqualsPtr(v.ScheduleToStartTimeoutSeconds, rhs.ScheduleToStartTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.ScheduleToCloseTimeoutSeconds, rhs.ScheduleToCloseTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.StartToCloseTimeoutSeconds, rhs.StartToCloseTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.HeartbeatTimeoutSeconds, rhs.HeartbeatTimeoutSeconds) {
		return false
	}
	if !_Bool_EqualsPtr(v.CancelRequested, rhs.CancelRequested) {
		return false
	}
	if !_I64_EqualsPtr(v.CancelRequestID, rhs.CancelRequestID) {
		return false
	}
	if !_I32_EqualsPtr(v.TimerTaskStatus, rhs.TimerTaskStatus) {
		return false
	}
	if !_I32_EqualsPtr(v.Attempt, rhs.Attempt) {
		return false
	}
	if !_String_EqualsPtr(v.TaskList, rhs.TaskList) {
		return false
	}
	if !_String_EqualsPtr(v.StartedIdentity, rhs.StartedIdentity) {
		return false
	}
	if !_Bool_EqualsPtr(v.HasRetryPolicy, rhs.HasRetryPolicy) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryInitialIntervalSeconds, rhs.RetryInitialIntervalSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryMaximumIntervalSeconds, rhs.RetryMaximumIntervalSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryMaximumAttempts, rhs.RetryMaximumAttempts) {
		return false
	}
	if !_I64_EqualsPtr(v.RetryExpirationTimeNanos, rhs.RetryExpirationTimeNanos) {
		return false
	}
	if !_Double_EqualsPtr(v.RetryBackoffCoefficient, rhs.RetryBackoffCoefficient) {
		return false
	}
	if !((v.RetryNonRetryableErrors == nil && rhs.RetryNonRetryableErrors == nil) || (v.RetryNonRetryableErrors != nil && rhs.RetryNonRetryableErrors != nil && _List_String_Equals(v.RetryNonRetryableErrors, rhs.RetryNonRetryableErrors))) {
		return false
	}
	if !_String_EqualsPtr(v.RetryLastFailureReason, rhs.RetryLastFailureReason) {
		return false
	}
	if !_String_EqualsPtr(v.RetryLastWorkerIdentity, rhs.RetryLastWorkerIdentity) {
		return false
	}
	if !((v.RetryLastFailureDetails == nil && rhs.RetryLastFailureDetails == nil) || (v.RetryLastFailureDetails != nil && rhs.RetryLastFailureDetails != nil && bytes.Equal(v.RetryLastFailureDetails, rhs.RetryLastFailureDetails))) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ActivityInfo.
func (v *ActivityInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.ScheduledEventBatchID != nil {
		enc.AddInt64("scheduledEventBatchID", *v.ScheduledEventBatchID)
	}
	if v.ScheduledEvent != nil {
		enc.AddString("scheduledEvent", base64.StdEncoding.EncodeToString(v.ScheduledEvent))
	}
	if v.ScheduledEventEncoding != nil {
		enc.AddString("scheduledEventEncoding", *v.ScheduledEventEncoding)
	}
	if v.ScheduledTimeNanos != nil {
		enc.AddInt64("scheduledTimeNanos", *v.ScheduledTimeNanos)
	}
	if v.StartedID != nil {
		enc.AddInt64("startedID", *v.StartedID)
	}
	if v.StartedEvent != nil {
		enc.AddString("startedEvent", base64.StdEncoding.EncodeToString(v.StartedEvent))
	}
	if v.StartedEventEncoding != nil {
		enc.AddString("startedEventEncoding", *v.StartedEventEncoding)
	}
	if v.StartedTimeNanos != nil {
		enc.AddInt64("startedTimeNanos", *v.StartedTimeNanos)
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.RequestID != nil {
		enc.AddString("requestID", *v.RequestID)
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		enc.AddInt32("scheduleToStartTimeoutSeconds", *v.ScheduleToStartTimeoutSeconds)
	}
	if v.ScheduleToCloseTimeoutSeconds != nil {
		enc.AddInt32("scheduleToCloseTimeoutSeconds", *v.ScheduleToCloseTimeoutSeconds)
	}
	if v.StartToCloseTimeoutSeconds != nil {
		enc.AddInt32("startToCloseTimeoutSeconds", *v.StartToCloseTimeoutSeconds)
	}
	if v.HeartbeatTimeoutSeconds != nil {
		enc.AddInt32("heartbeatTimeoutSeconds", *v.HeartbeatTimeoutSeconds)
	}
	if v.CancelRequested != nil {
		enc.AddBool("cancelRequested", *v.CancelRequested)
	}
	if v.CancelRequestID != nil {
		enc.AddInt64("cancelRequestID", *v.CancelRequestID)
	}
	if v.TimerTaskStatus != nil {
		enc.AddInt32("timerTaskStatus", *v.TimerTaskStatus)
	}
	if v.Attempt != nil {
		enc.AddInt32("attempt", *v.Attempt)
	}
	if v.TaskList != nil {
		enc.AddString("taskList", *v.TaskList)
	}
	if v.StartedIdentity != nil {
		enc.AddString("startedIdentity", *v.StartedIdentity)
	}
	if v.HasRetryPolicy != nil {
		enc.AddBool("hasRetryPolicy", *v.HasRetryPolicy)
	}
	if v.RetryInitialIntervalSeconds != nil {
		enc.AddInt32("retryInitialIntervalSeconds", *v.RetryInitialIntervalSeconds)
	}
	if v.RetryMaximumIntervalSeconds != nil {
		enc.AddInt32("retryMaximumIntervalSeconds", *v.RetryMaximumIntervalSeconds)
	}
	if v.RetryMaximumAttempts != nil {
		enc.AddInt32("retryMaximumAttempts", *v.RetryMaximumAttempts)
	}
	if v.RetryExpirationTimeNanos != nil {
		enc.AddInt64("retryExpirationTimeNanos", *v.RetryExpirationTimeNanos)
	}
	if v.RetryBackoffCoefficient != nil {
		enc.AddFloat64("retryBackoffCoefficient", *v.RetryBackoffCoefficient)
	}
	if v.RetryNonRetryableErrors != nil {
		err = multierr.Append(err, enc.AddArray("retryNonRetryableErrors", (_List_String_Zapper)(v.RetryNonRetryableErrors)))
	}
	if v.RetryLastFailureReason != nil {
		enc.AddString("retryLastFailureReason", *v.RetryLastFailureReason)
	}
	if v.RetryLastWorkerIdentity != nil {
		enc.AddString("retryLastWorkerIdentity", *v.RetryLastWorkerIdentity)
	}
	if v.RetryLastFailureDetails != nil {
		enc.AddString("retryLastFailureDetails", base64.StdEncoding.EncodeToString(v.RetryLastFailureDetails))
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *ActivityInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetScheduledEventBatchID returns the value of ScheduledEventBatchID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledEventBatchID() (o int64) {
	if v != nil && v.ScheduledEventBatchID != nil {
		return *v.ScheduledEventBatchID
	}

	return
}

// IsSetScheduledEventBatchID returns true if ScheduledEventBatchID is not nil.
func (v *ActivityInfo) IsSetScheduledEventBatchID() bool {
	return v != nil && v.ScheduledEventBatchID != nil
}

// GetScheduledEvent returns the value of ScheduledEvent if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledEvent() (o []byte) {
	if v != nil && v.ScheduledEvent != nil {
		return v.ScheduledEvent
	}

	return
}

// IsSetScheduledEvent returns true if ScheduledEvent is not nil.
func (v *ActivityInfo) IsSetScheduledEvent() bool {
	return v != nil && v.ScheduledEvent != nil
}

// GetScheduledEventEncoding returns the value of ScheduledEventEncoding if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledEventEncoding() (o string) {
	if v != nil && v.ScheduledEventEncoding != nil {
		return *v.ScheduledEventEncoding
	}

	return
}

// IsSetScheduledEventEncoding returns true if ScheduledEventEncoding is not nil.
func (v *ActivityInfo) IsSetScheduledEventEncoding() bool {
	return v != nil && v.ScheduledEventEncoding != nil
}

// GetScheduledTimeNanos returns the value of ScheduledTimeNanos if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledTimeNanos() (o int64) {
	if v != nil && v.ScheduledTimeNanos != nil {
		return *v.ScheduledTimeNanos
	}

	return
}

// IsSetScheduledTimeNanos returns true if ScheduledTimeNanos is not nil.
func (v *ActivityInfo) IsSetScheduledTimeNanos() bool {
	return v != nil && v.ScheduledTimeNanos != nil
}

// GetStartedID returns the value of StartedID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedID() (o int64) {
	if v != nil && v.StartedID != nil {
		return *v.StartedID
	}

	return
}

// IsSetStartedID returns true if StartedID is not nil.
func (v *ActivityInfo) IsSetStartedID() bool {
	return v != nil && v.StartedID != nil
}

// GetStartedEvent returns the value of StartedEvent if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedEvent() (o []byte) {
	if v != nil && v.StartedEvent != nil {
		return v.StartedEvent
	}

	return
}

// IsSetStartedEvent returns true if StartedEvent is not nil.
func (v *ActivityInfo) IsSetStartedEvent() bool {
	return v != nil && v.StartedEvent != nil
}

// GetStartedEventEncoding returns the value of StartedEventEncoding if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedEventEncoding() (o string) {
	if v != nil && v.StartedEventEncoding != nil {
		return *v.StartedEventEncoding
	}

	return
}

// IsSetStartedEventEncoding returns true if StartedEventEncoding is not nil.
func (v *ActivityInfo) IsSetStartedEventEncoding() bool {
	return v != nil && v.StartedEventEncoding != nil
}

// GetStartedTimeNanos returns the value of StartedTimeNanos if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedTimeNanos() (o int64) {
	if v != nil && v.StartedTimeNanos != nil {
		return *v.StartedTimeNanos
	}

	return
}

// IsSetStartedTimeNanos returns true if StartedTimeNanos is not nil.
func (v *ActivityInfo) IsSetStartedTimeNanos() bool {
	return v != nil && v.StartedTimeNanos != nil
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *ActivityInfo) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetRequestID returns the value of RequestID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRequestID() (o string) {
	if v != nil && v.RequestID != nil {
		return *v.RequestID
	}

	return
}

// IsSetRequestID returns true if RequestID is not nil.
func (v *ActivityInfo) IsSetRequestID() bool {
	return v != nil && v.RequestID != nil
}

// GetScheduleToStartTimeoutSeconds returns the value of ScheduleToStartTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduleToStartTimeoutSeconds() (o int32) {
	if v != nil && v.ScheduleToStartTimeoutSeconds != nil {
		return *v.ScheduleToStartTimeoutSeconds
	}

	return
}

// IsSetScheduleToStartTimeoutSeconds returns true if ScheduleToStartTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetScheduleToStartTimeoutSeconds() bool {
	return v != nil && v.ScheduleToStartTimeoutSeconds != nil
}

// GetScheduleToCloseTimeoutSeconds returns the value of ScheduleToCloseTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduleToCloseTimeoutSeconds() (o int32) {
	if v != nil && v.ScheduleToCloseTimeoutSeconds != nil {
		return *v.ScheduleToCloseTimeoutSeconds
	}

	return
}

// IsSetScheduleToCloseTimeoutSeconds returns true if ScheduleToCloseTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetScheduleToCloseTimeoutSeconds() bool {
	return v != nil && v.ScheduleToCloseTimeoutSeconds != nil
}

// GetStartToCloseTimeoutSeconds returns the value of StartToCloseTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartToCloseTimeoutSeconds() (o int32) {
	if v != nil && v.StartToCloseTimeoutSeconds != nil {
		return *v.StartToCloseTimeoutSeconds
	}

	return
}

// IsSetStartToCloseTimeoutSeconds returns true if StartToCloseTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetStartToCloseTimeoutSeconds() bool {
	return v != nil && v.StartToCloseTimeoutSeconds != nil
}

// GetHeartbeatTimeoutSeconds returns the value of HeartbeatTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetHeartbeatTimeoutSeconds() (o int32) {
	if v != nil && v.HeartbeatTimeoutSeconds != nil {
		return *v.HeartbeatTimeoutSeconds
	}

	return
}

// IsSetHeartbeatTimeoutSeconds returns true if HeartbeatTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetHeartbeatTimeoutSeconds() bool {
	return v != nil && v.HeartbeatTimeoutSeconds != nil
}

// GetCancelRequested returns the value of CancelRequested if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetCancelRequested() (o bool) {
	if v != nil && v.CancelRequested != nil {
		return *v.CancelRequested
	}

	return
}

// IsSetCancelRequested returns true if CancelRequested is not nil.
func (v *ActivityInfo) IsSetCancelRequested() bool {
	return v != nil && v.CancelRequested != nil
}

// GetCancelRequestID returns the value of CancelRequestID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetCancelRequestID() (o int64) {
	if v != nil && v.CancelRequestID != nil {
		return *v.CancelRequestID
	}

	return
}

// IsSetCancelRequestID returns true if CancelRequestID is not nil.
func (v *ActivityInfo) IsSetCancelRequestID() bool {
	return v != nil && v.CancelRequestID != nil
}

// GetTimerTaskStatus returns the value of TimerTaskStatus if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetTimerTaskStatus() (o int32) {
	if v != nil && v.TimerTaskStatus != nil {
		return *v.TimerTaskStatus
	}

	return
}

// IsSetTimerTaskStatus returns true if TimerTaskStatus is not nil.
func (v *ActivityInfo) IsSetTimerTaskStatus() bool {
	return v != nil && v.TimerTaskStatus != nil
}

// GetAttempt returns the value of Attempt if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetAttempt() (o int32) {
	if v != nil && v.Attempt != nil {
		return *v.Attempt
	}

	return
}

// IsSetAttempt returns true if Attempt is not nil.
func (v *ActivityInfo) IsSetAttempt() bool {
	return v != nil && v.Attempt != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetTaskList() (o string) {
	if v != nil && v.TaskList != nil {
		return *v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *ActivityInfo) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetStartedIdentity returns the value of StartedIdentity if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedIdentity() (o string) {
	if v != nil && v.StartedIdentity != nil {
		return *v.StartedIdentity
	}

	return
}

// IsSetStartedIdentity returns true if StartedIdentity is not nil.
func (v *ActivityInfo) IsSetStartedIdentity() bool {
	return v != nil && v.StartedIdentity != nil
}

// GetHasRetryPolicy returns the value of HasRetryPolicy if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetHasRetryPolicy() (o bool) {
	if v != nil && v.HasRetryPolicy != nil {
		return *v.HasRetryPolicy
	}

	return
}

// IsSetHasRetryPolicy returns true if HasRetryPolicy is not nil.
func (v *ActivityInfo) IsSetHasRetryPolicy() bool {
	return v != nil && v.HasRetryPolicy != nil
}

// GetRetryInitialIntervalSeconds returns the value of RetryInitialIntervalSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryInitialIntervalSeconds() (o int32) {
	if v != nil && v.RetryInitialIntervalSeconds != nil {
		return *v.RetryInitialIntervalSeconds
	}

	return
}

// IsSetRetryInitialIntervalSeconds returns true if RetryInitialIntervalSeconds is not nil.
func (v *ActivityInfo) IsSetRetryInitialIntervalSeconds() bool {
	return v != nil && v.RetryInitialIntervalSeconds != nil
}

// GetRetryMaximumIntervalSeconds returns the value of RetryMaximumIntervalSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryMaximumIntervalSeconds() (o int32) {
	if v != nil && v.RetryMaximumIntervalSeconds != nil {
		return *v.RetryMaximumIntervalSeconds
	}

	return
}

// IsSetRetryMaximumIntervalSeconds returns true if RetryMaximumIntervalSeconds is not nil.
func (v *ActivityInfo) IsSetRetryMaximumIntervalSeconds() bool {
	return v != nil && v.RetryMaximumIntervalSeconds != nil
}

// GetRetryMaximumAttempts returns the value of RetryMaximumAttempts if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryMaximumAttempts() (o int32) {
	if v != nil && v.RetryMaximumAttempts != nil {
		return *v.RetryMaximumAttempts
	}

	return
}

// IsSetRetryMaximumAttempts returns true if RetryMaximumAttempts is not nil.
func (v *ActivityInfo) IsSetRetryMaximumAttempts() bool {
	return v != nil && v.RetryMaximumAttempts != nil
}

// GetRetryExpirationTimeNanos returns the value of RetryExpirationTimeNanos if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryExpirationTimeNanos() (o int64) {
	if v != nil && v.RetryExpirationTimeNanos != nil {
		return *v.RetryExpirationTimeNanos
	}

	return
}

// IsSetRetryExpirationTimeNanos returns true if RetryExpirationTimeNanos is not nil.
func (v *ActivityInfo) IsSetRetryExpirationTimeNanos() bool {
	return v != nil && v.RetryExpirationTimeNanos != nil
}

// GetRetryBackoffCoefficient returns the value of RetryBackoffCoefficient if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryBackoffCoefficient() (o float64) {
	if v != nil && v.RetryBackoffCoefficient != nil {
		return *v.RetryBackoffCoefficient
	}

	return
}

// IsSetRetryBackoffCoefficient returns true if RetryBackoffCoefficient is not nil.
func (v *ActivityInfo) IsSetRetryBackoffCoefficient() bool {
	return v != nil && v.RetryBackoffCoefficient != nil
}

// GetRetryNonRetryableErrors returns the value of RetryNonRetryableErrors if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryNonRetryableErrors() (o []string) {
	if v != nil && v.RetryNonRetryableErrors != nil {
		return v.RetryNonRetryableErrors
	}

	return
}

// IsSetRetryNonRetryableErrors returns true if RetryNonRetryableErrors is not nil.
func (v *ActivityInfo) IsSetRetryNonRetryableErrors() bool {
	return v != nil && v.RetryNonRetryableErrors != nil
}

// GetRetryLastFailureReason returns the value of RetryLastFailureReason if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryLastFailureReason() (o string) {
	if v != nil && v.RetryLastFailureReason != nil {
		return *v.RetryLastFailureReason
	}

	return
}

// IsSetRetryLastFailureReason returns true if RetryLastFailureReason is not nil.
func (v *ActivityInfo) IsSetRetryLastFailureReason() bool {
	return v != nil && v.RetryLastFailureReason != nil
}

// GetRetryLastWorkerIdentity returns the value of RetryLastWorkerIdentity if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryLastWorkerIdentity() (o string) {
	if v != nil && v.RetryLastWorkerIdentity != nil {
		return *v.RetryLastWorkerIdentity
	}

	return
}

// IsSetRetryLastWorkerIdentity returns true if RetryLastWorkerIdentity is not nil.
func (v *ActivityInfo) IsSetRetryLastWorkerIdentity() bool {
	return v != nil && v.RetryLastWorkerIdentity != nil
}

// GetRetryLastFailureDetails returns the value of RetryLastFailureDetails if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryLastFailureDetails() (o []byte) {
	if v != nil && v.RetryLastFailureDetails != nil {
		return v.RetryLastFailureDetails
	}

	return
}

// IsSetRetryLastFailureDetails returns true if RetryLastFailureDetails is not nil.
func (v *ActivityInfo) IsSetRetryLastFailureDetails() bool {
	return v != nil && v.RetryLastFailureDetails != nil
}

type AsyncRequestMessage struct {
	PartitionKey *string           `json:"partitionKey,omitempty"`
	Type         *AsyncRequestType `json:"type,omitempty"`
	Header       *shared.Header    `json:"header,omitempty"`
	Encoding     *string           `json:"encoding,omitempty"`
	Payload      []byte            `json:"payload,omitempty"`
}

// ToWire translates a AsyncRequestMessage struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *AsyncRequestMessage) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.PartitionKey != nil {
		w, err = wire.NewValueString(*(v.PartitionKey)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.Header != nil {
		w, err = v.Header.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.Encoding != nil {
		w, err = wire.NewValueString(*(v.Encoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.Payload != nil {
		w, err = wire.NewValueBinary(v.Payload), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _AsyncRequestType_Read(w wire.Value) (AsyncRequestType, error) {
	var v AsyncRequestType
	err := v.FromWire(w)
	return v, err
}

func _Header_Read(w wire.Value) (*shared.Header, error) {
	var v shared.Header
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a AsyncRequestMessage struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a AsyncRequestMessage struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v AsyncRequestMessage
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *AsyncRequestMessage) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.PartitionKey = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x AsyncRequestType
				x, err = _AsyncRequestType_Read(field.Value)
				v.Type = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TStruct {
				v.Header, err = _Header_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Encoding = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TBinary {
				v.Payload, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a AsyncRequestMessage struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a AsyncRequestMessage struct could not be encoded.
func (v *AsyncRequestMessage) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.PartitionKey != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.PartitionKey)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Type != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI32}); err != nil {
			return err
		}
		if err := v.Type.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Header != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Header.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Encoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Encoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Payload != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.Payload); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _AsyncRequestType_Decode(sr stream.Reader) (AsyncRequestType, error) {
	var v AsyncRequestType
	err := v.Decode(sr)
	return v, err
}

func _Header_Decode(sr stream.Reader) (*shared.Header, error) {
	var v shared.Header
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a AsyncRequestMessage struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a AsyncRequestMessage struct could not be generated from the wire
// representation.
func (v *AsyncRequestMessage) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.PartitionKey = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI32:
			var x AsyncRequestType
			x, err = _AsyncRequestType_Decode(sr)
			v.Type = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TStruct:
			v.Header, err = _Header_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Encoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TBinary:
			v.Payload, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a AsyncRequestMessage
// struct.
func (v *AsyncRequestMessage) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.PartitionKey != nil {
		fields[i] = fmt.Sprintf("PartitionKey: %v", *(v.PartitionKey))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}
	if v.Header != nil {
		fields[i] = fmt.Sprintf("Header: %v", v.Header)
		i++
	}
	if v.Encoding != nil {
		fields[i] = fmt.Sprintf("Encoding: %v", *(v.Encoding))
		i++
	}
	if v.Payload != nil {
		fields[i] = fmt.Sprintf("Payload: %v", v.Payload)
		i++
	}

	return fmt.Sprintf("AsyncRequestMessage{%v}", strings.Join(fields[:i], ", "))
}

func _AsyncRequestType_EqualsPtr(lhs, rhs *AsyncRequestType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this AsyncRequestMessage match the
// provided AsyncRequestMessage.
//
// This function performs a deep comparison.
func (v *AsyncRequestMessage) Equals(rhs *AsyncRequestMessage) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.PartitionKey, rhs.PartitionKey) {
		return false
	}
	if !_AsyncRequestType_EqualsPtr(v.Type, rhs.Type) {
		return false
	}
	if !((v.Header == nil && rhs.Header == nil) || (v.Header != nil && rhs.Header != nil && v.Header.Equals(rhs.Header))) {
		return false
	}
	if !_String_EqualsPtr(v.Encoding, rhs.Encoding) {
		return false
	}
	if !((v.Payload == nil && rhs.Payload == nil) || (v.Payload != nil && rhs.Payload != nil && bytes.Equal(v.Payload, rhs.Payload))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of AsyncRequestMessage.
func (v *AsyncRequestMessage) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.PartitionKey != nil {
		enc.AddString("partitionKey", *v.PartitionKey)
	}
	if v.Type != nil {
		err = multierr.Append(err, enc.AddObject("type", *v.Type))
	}
	if v.Header != nil {
		err = multierr.Append(err, enc.AddObject("header", v.Header))
	}
	if v.Encoding != nil {
		enc.AddString("encoding", *v.Encoding)
	}
	if v.Payload != nil {
		enc.AddString("payload", base64.StdEncoding.EncodeToString(v.Payload))
	}
	return err
}

// GetPartitionKey returns the value of PartitionKey if it is set or its
// zero value if it is unset.
func (v *AsyncRequestMessage) GetPartitionKey() (o string) {
	if v != nil && v.PartitionKey != nil {
		return *v.PartitionKey
	}

	return
}

// IsSetPartitionKey returns true if PartitionKey is not nil.
func (v *AsyncRequestMessage) IsSetPartitionKey() bool {
	return v != nil && v.PartitionKey != nil
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *AsyncRequestMessage) GetType() (o AsyncRequestType) {
	if v != nil && v.Type != nil {
		return *v.Type
	}

	return
}

// IsSetType returns true if Type is not nil.
func (v *AsyncRequestMessage) IsSetType() bool {
	return v != nil && v.Type != nil
}

// GetHeader returns the value of Header if it is set or its
// zero value if it is unset.
func (v *AsyncRequestMessage) GetHeader() (o *shared.Header) {
	if v != nil && v.Header != nil {
		return v.Header
	}

	return
}

// IsSetHeader returns true if Header is not nil.
func (v *AsyncRequestMessage) IsSetHeader() bool {
	return v != nil && v.Header != nil
}

// GetEncoding returns the value of Encoding if it is set or its
// zero value if it is unset.
func (v *AsyncRequestMessage) GetEncoding() (o string) {
	if v != nil && v.Encoding != nil {
		return *v.Encoding
	}

	return
}

// IsSetEncoding returns true if Encoding is not nil.
func (v *AsyncRequestMessage) IsSetEncoding() bool {
	return v != nil && v.Encoding != nil
}

// GetPayload returns the value of Payload if it is set or its
// zero value if it is unset.
func (v *AsyncRequestMessage) GetPayload() (o []byte) {
	if v != nil && v.Payload != nil {
		return v.Payload
	}

	return
}

// IsSetPayload returns true if Payload is not nil.
func (v *AsyncRequestMessage) IsSetPayload() bool {
	return v != nil && v.Payload != nil
}

type AsyncRequestType int32

const (
	AsyncRequestTypeStartWorkflowExecutionAsyncRequest           AsyncRequestType = 0
	AsyncRequestTypeSignalWithStartWorkflowExecutionAsyncRequest AsyncRequestType = 1
)

// AsyncRequestType_Values returns all recognized values of AsyncRequestType.
func AsyncRequestType_Values() []AsyncRequestType {
	return []AsyncRequestType{
		AsyncRequestTypeStartWorkflowExecutionAsyncRequest,
		AsyncRequestTypeSignalWithStartWorkflowExecutionAsyncRequest,
	}
}

// UnmarshalText tries to decode AsyncRequestType from a byte slice
// containing its name.
//
//	var v AsyncRequestType
//	err := v.UnmarshalText([]byte("StartWorkflowExecutionAsyncRequest"))
func (v *AsyncRequestType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "StartWorkflowExecutionAsyncRequest":
		*v = AsyncRequestTypeStartWorkflowExecutionAsyncRequest
		return nil
	case "SignalWithStartWorkflowExecutionAsyncRequest":
		*v = AsyncRequestTypeSignalWithStartWorkflowExecutionAsyncRequest
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "AsyncRequestType", err)
		}
		*v = AsyncRequestType(val)
		return nil
	}
}

// MarshalText encodes AsyncRequestType to text.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v AsyncRequestType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("StartWorkflowExecutionAsyncRequest"), nil
	case 1:
		return []byte("SignalWithStartWorkflowExecutionAsyncRequest"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of AsyncRequestType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v AsyncRequestType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "StartWorkflowExecutionAsyncRequest")
	case 1:
		enc.AddString("name", "SignalWithStartWorkflowExecutionAsyncRequest")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v AsyncRequestType) Ptr() *AsyncRequestType {
	return &v
}

// Encode encodes AsyncRequestType directly to bytes.
//
//	sWriter := BinaryStreamer.Writer(writer)
//
//	var v AsyncRequestType
//	return v.Encode(sWriter)
func (v AsyncRequestType) Encode(sw stream.Writer) error {
	return sw.WriteInt32(int32(v))
}

// ToWire translates AsyncRequestType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v AsyncRequestType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes AsyncRequestType from its Thrift-level
// representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TI32)
//	if err != nil {
//	  return AsyncRequestType(0), err
//	}
//
//	var v AsyncRequestType
//	if err := v.FromWire(x); err != nil {
//	  return AsyncRequestType(0), err
//	}
//	return v, nil
func (v *AsyncRequestType) FromWire(w wire.Value) error {
	*v = (AsyncRequestType)(w.GetI32())
	return nil
}

// Decode reads off the encoded AsyncRequestType directly off of the wire.
//
//	sReader := BinaryStreamer.Reader(reader)
//
//	var v AsyncRequestType
//	if err := v.Decode(sReader); err != nil {
//	  return AsyncRequestType(0), err
//	}
//	return v, nil
func (v *AsyncRequestType) Decode(sr stream.Reader) error {
	i, err := sr.ReadInt32()
	if err != nil {
		return err
	}
	*v = (AsyncRequestType)(i)
	return nil
}

// String returns a readable string representation of AsyncRequestType.
func (v AsyncRequestType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "StartWorkflowExecutionAsyncRequest"
	case 1:
		return "SignalWithStartWorkflowExecutionAsyncRequest"
	}
	return fmt.Sprintf("AsyncRequestType(%d)", w)
}

// Equals returns true if this AsyncRequestType value matches the provided
// value.
func (v AsyncRequestType) Equals(rhs AsyncRequestType) bool {
	return v == rhs
}

// MarshalJSON serializes AsyncRequestType into JSON.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements json.Marshaler.
func (v AsyncRequestType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"StartWorkflowExecutionAsyncRequest\""), nil
	case 1:
		return ([]byte)("\"SignalWithStartWorkflowExecutionAsyncRequest\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode AsyncRequestType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *AsyncRequestType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "AsyncRequestType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "AsyncRequestType")
		}
		*v = (AsyncRequestType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "AsyncRequestType")
	}
}

type ChildExecutionInfo struct {
	Version                *int64  `json:"version,omitempty"`
	InitiatedEventBatchID  *int64  `json:"initiatedEventBatchID,omitempty"`
	StartedID              *int64  `json:"startedID,omitempty"`
	InitiatedEvent         []byte  `json:"initiatedEvent,omitempty"`
	InitiatedEventEncoding *string `json:"initiatedEventEncoding,omitempty"`
	StartedWorkflowID      *string `json:"startedWorkflowID,omitempty"`
	StartedRunID           []byte  `json:"startedRunID,omitempty"`
	StartedEvent           []byte  `json:"startedEvent,omitempty"`
	StartedEventEncoding   *string `json:"startedEventEncoding,omitempty"`
	CreateRequestID        *string `json:"createRequestID,omitempty"`
	DomainID               *string `json:"domainID,omitempty"`
	DomainName             *string `json:"domainName,omitempty"`
	WorkflowTypeName       *string `json:"workflowTypeName,omitempty"`
	ParentClosePolicy      *int32  `json:"parentClosePolicy,omitempty"`
}

// ToWire translates a ChildExecutionInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *ChildExecutionInfo) ToWire() (wire.Value, error) {
	var (
		fields [14]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.InitiatedEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.InitiatedEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.StartedID != nil {
		w, err = wire.NewValueI64(*(v.StartedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.InitiatedEvent != nil {
		w, err = wire.NewValueBinary(v.InitiatedEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.InitiatedEventEncoding != nil {
		w, err = wire.NewValueString(*(v.InitiatedEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.StartedWorkflowID != nil {
		w, err = wire.NewValueString(*(v.StartedWorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.StartedRunID != nil {
		w, err = wire.NewValueBinary(v.StartedRunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.StartedEvent != nil {
		w, err = wire.NewValueBinary(v.StartedEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.StartedEventEncoding != nil {
		w, err = wire.NewValueString(*(v.StartedEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.CreateRequestID != nil {
		w, err = wire.NewValueString(*(v.CreateRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.DomainID != nil {
		w, err = wire.NewValueString(*(v.DomainID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 29, Value: w}
		i++
	}
	if v.DomainName != nil {
		w, err = wire.NewValueString(*(v.DomainName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.WorkflowTypeName != nil {
		w, err = wire.NewValueString(*(v.WorkflowTypeName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.ParentClosePolicy != nil {
		w, err = wire.NewValueI32(*(v.ParentClosePolicy)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 35, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ChildExecutionInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ChildExecutionInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v ChildExecutionInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *ChildExecutionInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.InitiatedEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedID = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				v.InitiatedEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.InitiatedEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedWorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				v.StartedRunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TBinary {
				v.StartedEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CreateRequestID = &x
				if err != nil {
					return err
				}

			}
		case 29:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.DomainID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.DomainName = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowTypeName = &x
				if err != nil {
					return err
				}

			}
		case 35:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ParentClosePolicy = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ChildExecutionInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ChildExecutionInfo struct could not be encoded.
func (v *ChildExecutionInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.InitiatedEventBatchID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.InitiatedEventBatchID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StartedID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.InitiatedEvent != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.InitiatedEvent); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.InitiatedEventEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.InitiatedEventEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedWorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.StartedWorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedRunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.StartedRunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedEvent != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.StartedEvent); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedEventEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 26, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.StartedEventEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CreateRequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 28, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CreateRequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DomainID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 29, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.DomainID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DomainName != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 30, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.DomainName)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WorkflowTypeName != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 32, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.WorkflowTypeName)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ParentClosePolicy != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 35, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ParentClosePolicy)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ChildExecutionInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ChildExecutionInfo struct could not be generated from the wire
// representation.
func (v *ChildExecutionInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.InitiatedEventBatchID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StartedID = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TBinary:
			v.InitiatedEvent, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.InitiatedEventEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.StartedWorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TBinary:
			v.StartedRunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TBinary:
			v.StartedEvent, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 26 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.StartedEventEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 28 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CreateRequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 29 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.DomainID = &x
			if err != nil {
				return err
			}

		case fh.ID == 30 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.DomainName = &x
			if err != nil {
				return err
			}

		case fh.ID == 32 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.WorkflowTypeName = &x
			if err != nil {
				return err
			}

		case fh.ID == 35 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ParentClosePolicy = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ChildExecutionInfo
// struct.
func (v *ChildExecutionInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [14]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.InitiatedEventBatchID != nil {
		fields[i] = fmt.Sprintf("InitiatedEventBatchID: %v", *(v.InitiatedEventBatchID))
		i++
	}
	if v.StartedID != nil {
		fields[i] = fmt.Sprintf("StartedID: %v", *(v.StartedID))
		i++
	}
	if v.InitiatedEvent != nil {
		fields[i] = fmt.Sprintf("InitiatedEvent: %v", v.InitiatedEvent)
		i++
	}
	if v.InitiatedEventEncoding != nil {
		fields[i] = fmt.Sprintf("InitiatedEventEncoding: %v", *(v.InitiatedEventEncoding))
		i++
	}
	if v.StartedWorkflowID != nil {
		fields[i] = fmt.Sprintf("StartedWorkflowID: %v", *(v.StartedWorkflowID))
		i++
	}
	if v.StartedRunID != nil {
		fields[i] = fmt.Sprintf("StartedRunID: %v", v.StartedRunID)
		i++
	}
	if v.StartedEvent != nil {
		fields[i] = fmt.Sprintf("StartedEvent: %v", v.StartedEvent)
		i++
	}
	if v.StartedEventEncoding != nil {
		fields[i] = fmt.Sprintf("StartedEventEncoding: %v", *(v.StartedEventEncoding))
		i++
	}
	if v.CreateRequestID != nil {
		fields[i] = fmt.Sprintf("CreateRequestID: %v", *(v.CreateRequestID))
		i++
	}
	if v.DomainID != nil {
		fields[i] = fmt.Sprintf("DomainID: %v", *(v.DomainID))
		i++
	}
	if v.DomainName != nil {
		fields[i] = fmt.Sprintf("DomainName: %v", *(v.DomainName))
		i++
	}
	if v.WorkflowTypeName != nil {
		fields[i] = fmt.Sprintf("WorkflowTypeName: %v", *(v.WorkflowTypeName))
		i++
	}
	if v.ParentClosePolicy != nil {
		fields[i] = fmt.Sprintf("ParentClosePolicy: %v", *(v.ParentClosePolicy))
		i++
	}

	return fmt.Sprintf("ChildExecutionInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ChildExecutionInfo match the
// provided ChildExecutionInfo.
//
// This function performs a deep comparison.
func (v *ChildExecutionInfo) Equals(rhs *ChildExecutionInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.InitiatedEventBatchID, rhs.InitiatedEventBatchID) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedID, rhs.StartedID) {
		return false
	}
	if !((v.InitiatedEvent == nil && rhs.InitiatedEvent == nil) || (v.InitiatedEvent != nil && rhs.InitiatedEvent != nil && bytes.Equal(v.InitiatedEvent, rhs.InitiatedEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.InitiatedEventEncoding, rhs.InitiatedEventEncoding) {
		return false
	}
	if !_String_EqualsPtr(v.StartedWorkflowID, rhs.StartedWorkflowID) {
		return false
	}
	if !((v.StartedRunID == nil && rhs.StartedRunID == nil) || (v.StartedRunID != nil && rhs.StartedRunID != nil && bytes.Equal(v.StartedRunID, rhs.StartedRunID))) {
		return false
	}
	if !((v.StartedEvent == nil && rhs.StartedEvent == nil) || (v.StartedEvent != nil && rhs.StartedEvent != nil && bytes.Equal(v.StartedEvent, rhs.StartedEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.StartedEventEncoding, rhs.StartedEventEncoding) {
		return false
	}
	if !_String_EqualsPtr(v.CreateRequestID, rhs.CreateRequestID) {
		return false
	}
	if !_String_EqualsPtr(v.DomainID, rhs.DomainID) {
		return false
	}
	if !_String_EqualsPtr(v.DomainName, rhs.DomainName) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowTypeName, rhs.WorkflowTypeName) {
		return false
	}
	if !_I32_EqualsPtr(v.ParentClosePolicy, rhs.ParentClosePolicy) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ChildExecutionInfo.
func (v *ChildExecutionInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.InitiatedEventBatchID != nil {
		enc.AddInt64("initiatedEventBatchID", *v.InitiatedEventBatchID)
	}
	if v.StartedID != nil {
		enc.AddInt64("startedID", *v.StartedID)
	}
	if v.InitiatedEvent != nil {
		enc.AddString("initiatedEvent", base64.StdEncoding.EncodeToString(v.InitiatedEvent))
	}
	if v.InitiatedEventEncoding != nil {
		enc.AddString("initiatedEventEncoding", *v.InitiatedEventEncoding)
	}
	if v.StartedWorkflowID != nil {
		enc.AddString("startedWorkflowID", *v.StartedWorkflowID)
	}
	if v.StartedRunID != nil {
		enc.AddString("startedRunID", base64.StdEncoding.EncodeToString(v.StartedRunID))
	}
	if v.StartedEvent != nil {
		enc.AddString("startedEvent", base64.StdEncoding.EncodeToString(v.StartedEvent))
	}
	if v.StartedEventEncoding != nil {
		enc.AddString("startedEventEncoding", *v.StartedEventEncoding)
	}
	if v.CreateRequestID != nil {
		enc.AddString("createRequestID", *v.CreateRequestID)
	}
	if v.DomainID != nil {
		enc.AddString("domainID", *v.DomainID)
	}
	if v.DomainName != nil {
		enc.AddString("domainName", *v.DomainName)
	}
	if v.WorkflowTypeName != nil {
		enc.AddString("workflowTypeName", *v.WorkflowTypeName)
	}
	if v.ParentClosePolicy != nil {
		enc.AddInt32("parentClosePolicy", *v.ParentClosePolicy)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *ChildExecutionInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetInitiatedEventBatchID returns the value of InitiatedEventBatchID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetInitiatedEventBatchID() (o int64) {
	if v != nil && v.InitiatedEventBatchID != nil {
		return *v.InitiatedEventBatchID
	}

	return
}

// IsSetInitiatedEventBatchID returns true if InitiatedEventBatchID is not nil.
func (v *ChildExecutionInfo) IsSetInitiatedEventBatchID() bool {
	return v != nil && v.InitiatedEventBatchID != nil
}

// GetStartedID returns the value of StartedID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedID() (o int64) {
	if v != nil && v.StartedID != nil {
		return *v.StartedID
	}

	return
}

// IsSetStartedID returns true if StartedID is not nil.
func (v *ChildExecutionInfo) IsSetStartedID() bool {
	return v != nil && v.StartedID != nil
}

// GetInitiatedEvent returns the value of InitiatedEvent if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetInitiatedEvent() (o []byte) {
	if v != nil && v.InitiatedEvent != nil {
		return v.InitiatedEvent
	}

	return
}

// IsSetInitiatedEvent returns true if InitiatedEvent is not nil.
func (v *ChildExecutionInfo) IsSetInitiatedEvent() bool {
	return v != nil && v.InitiatedEvent != nil
}

// GetInitiatedEventEncoding returns the value of InitiatedEventEncoding if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetInitiatedEventEncoding() (o string) {
	if v != nil && v.InitiatedEventEncoding != nil {
		return *v.InitiatedEventEncoding
	}

	return
}

// IsSetInitiatedEventEncoding returns true if InitiatedEventEncoding is not nil.
func (v *ChildExecutionInfo) IsSetInitiatedEventEncoding() bool {
	return v != nil && v.InitiatedEventEncoding != nil
}

// GetStartedWorkflowID returns the value of StartedWorkflowID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedWorkflowID() (o string) {
	if v != nil && v.StartedWorkflowID != nil {
		return *v.StartedWorkflowID
	}

	return
}

// IsSetStartedWorkflowID returns true if StartedWorkflowID is not nil.
func (v *ChildExecutionInfo) IsSetStartedWorkflowID() bool {
	return v != nil && v.StartedWorkflowID != nil
}

// GetStartedRunID returns the value of StartedRunID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedRunID() (o []byte) {
	if v != nil && v.StartedRunID != nil {
		return v.StartedRunID
	}

	return
}

// IsSetStartedRunID returns true if StartedRunID is not nil.
func (v *ChildExecutionInfo) IsSetStartedRunID() bool {
	return v != nil && v.StartedRunID != nil
}

// GetStartedEvent returns the value of StartedEvent if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedEvent() (o []byte) {
	if v != nil && v.StartedEvent != nil {
		return v.StartedEvent
	}

	return
}

// IsSetStartedEvent returns true if StartedEvent is not nil.
func (v *ChildExecutionInfo) IsSetStartedEvent() bool {
	return v != nil && v.StartedEvent != nil
}

// GetStartedEventEncoding returns the value of StartedEventEncoding if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedEventEncoding() (o string) {
	if v != nil && v.StartedEventEncoding != nil {
		return *v.StartedEventEncoding
	}

	return
}

// IsSetStartedEventEncoding returns true if StartedEventEncoding is not nil.
func (v *ChildExecutionInfo) IsSetStartedEventEncoding() bool {
	return v != nil && v.StartedEventEncoding != nil
}

// GetCreateRequestID returns the value of CreateRequestID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetCreateRequestID() (o string) {
	if v != nil && v.CreateRequestID != nil {
		return *v.CreateRequestID
	}

	return
}

// IsSetCreateRequestID returns true if CreateRequestID is not nil.
func (v *ChildExecutionInfo) IsSetCreateRequestID() bool {
	return v != nil && v.CreateRequestID != nil
}

// GetDomainID returns the value of DomainID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetDomainID() (o string) {
	if v != nil && v.DomainID != nil {
		return *v.DomainID
	}

	return
}

// IsSetDomainID returns true if DomainID is not nil.
func (v *ChildExecutionInfo) IsSetDomainID() bool {
	return v != nil && v.DomainID != nil
}

// GetDomainName returns the value of DomainName if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetDomainName() (o string) {
	if v != nil && v.DomainName != nil {
		return *v.DomainName
	}

	return
}

// IsSetDomainName returns true if DomainName is not nil.
func (v *ChildExecutionInfo) IsSetDomainName() bool {
	return v != nil && v.DomainName != nil
}

// GetWorkflowTypeName returns the value of WorkflowTypeName if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetWorkflowTypeName() (o string) {
	if v != nil && v.WorkflowTypeName != nil {
		return *v.WorkflowTypeName
	}

	return
}

// IsSetWorkflowTypeName returns true if WorkflowTypeName is not nil.
func (v *ChildExecutionInfo) IsSetWorkflowTypeName() bool {
	return v != nil && v.WorkflowTypeName != nil
}

// GetParentClosePolicy returns the value of ParentClosePolicy if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetParentClosePolicy() (o int32) {
	if v != nil && v.ParentClosePolicy != nil {
		return *v.ParentClosePolicy
	}

	return
}

// IsSetParentClosePolicy returns true if ParentClosePolicy is not nil.
func (v *ChildExecutionInfo) IsSetParentClosePolicy() bool {
	return v != nil && v.ParentClosePolicy != nil
}

type DomainInfo struct {
	Name                                 *string           `json:"name,omitempty"`
	Description                          *string           `json:"description,omitempty"`
	Owner                                *string           `json:"owner,omitempty"`
	Status                               *int32            `json:"status,omitempty"`
	RetentionDays                        *int16            `json:"retentionDays,omitempty"`
	EmitMetric                           *bool             `json:"emitMetric,omitempty"`
	ArchivalBucket                       *string           `json:"archivalBucket,omitempty"`
	ArchivalStatus                       *int16            `json:"archivalStatus,omitempty"`
	ConfigVersion                        *int64            `json:"configVersion,omitempty"`
	NotificationVersion                  *int64            `json:"notificationVersion,omitempty"`
	FailoverNotificationVersion          *int64            `json:"failoverNotificationVersion,omitempty"`
	FailoverVersion                      *int64            `json:"failoverVersion,omitempty"`
	ActiveClusterName                    *string           `json:"activeClusterName,omitempty"`
	Clusters                             []string          `json:"clusters,omitempty"`
	Data                                 map[string]string `json:"data,omitempty"`
	BadBinaries                          []byte            `json:"badBinaries,omitempty"`
	BadBinariesEncoding                  *string           `json:"badBinariesEncoding,omitempty"`
	HistoryArchivalStatus                *int16            `json:"historyArchivalStatus,omitempty"`
	HistoryArchivalURI                   *string           `json:"historyArchivalURI,omitempty"`
	VisibilityArchivalStatus             *int16            `json:"visibilityArchivalStatus,omitempty"`
	VisibilityArchivalURI                *string           `json:"visibilityArchivalURI,omitempty"`
	FailoverEndTime                      *int64            `json:"failoverEndTime,omitempty"`
	PreviousFailoverVersion              *int64            `json:"previousFailoverVersion,omitempty"`
	LastUpdatedTime                      *int64            `json:"lastUpdatedTime,omitempty"`
	IsolationGroupsConfiguration         []byte            `json:"isolationGroupsConfiguration,omitempty"`
	IsolationGroupsConfigurationEncoding *string           `json:"isolationGroupsConfigurationEncoding,omitempty"`
	AsyncWorkflowConfiguration           []byte            `json:"asyncWorkflowConfiguration,omitempty"`
	AsyncWorkflowConfigurationEncoding   *string           `json:"asyncWorkflowConfigurationEncoding,omitempty"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a DomainInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *DomainInfo) ToWire() (wire.Value, error) {
	var (
		fields [28]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Description != nil {
		w, err = wire.NewValueString(*(v.Description)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.Owner != nil {
		w, err = wire.NewValueString(*(v.Owner)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = wire.NewValueI32(*(v.Status)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.RetentionDays != nil {
		w, err = wire.NewValueI16(*(v.RetentionDays)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.EmitMetric != nil {
		w, err = wire.NewValueBool(*(v.EmitMetric)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.ArchivalBucket != nil {
		w, err = wire.NewValueString(*(v.ArchivalBucket)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.ArchivalStatus != nil {
		w, err = wire.NewValueI16(*(v.ArchivalStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.ConfigVersion != nil {
		w, err = wire.NewValueI64(*(v.ConfigVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.NotificationVersion != nil {
		w, err = wire.NewValueI64(*(v.NotificationVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.FailoverNotificationVersion != nil {
		w, err = wire.NewValueI64(*(v.FailoverNotificationVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.FailoverVersion != nil {
		w, err = wire.NewValueI64(*(v.FailoverVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.ActiveClusterName != nil {
		w, err = wire.NewValueString(*(v.ActiveClusterName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.Clusters != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Clusters)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 36, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Data)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}
	if v.BadBinaries != nil {
		w, err = wire.NewValueBinary(v.BadBinaries), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 39, Value: w}
		i++
	}
	if v.BadBinariesEncoding != nil {
		w, err = wire.NewValueString(*(v.BadBinariesEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.HistoryArchivalStatus != nil {
		w, err = wire.NewValueI16(*(v.HistoryArchivalStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 42, Value: w}
		i++
	}
	if v.HistoryArchivalURI != nil {
		w, err = wire.NewValueString(*(v.HistoryArchivalURI)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 44, Value: w}
		i++
	}
	if v.VisibilityArchivalStatus != nil {
		w, err = wire.NewValueI16(*(v.VisibilityArchivalStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 46, Value: w}
		i++
	}
	if v.VisibilityArchivalURI != nil {
		w, err = wire.NewValueString(*(v.VisibilityArchivalURI)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 48, Value: w}
		i++
	}
	if v.FailoverEndTime != nil {
		w, err = wire.NewValueI64(*(v.FailoverEndTime)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.PreviousFailoverVersion != nil {
		w, err = wire.NewValueI64(*(v.PreviousFailoverVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 52, Value: w}
		i++
	}
	if v.LastUpdatedTime != nil {
		w, err = wire.NewValueI64(*(v.LastUpdatedTime)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 54, Value: w}
		i++
	}
	if v.IsolationGroupsConfiguration != nil {
		w, err = wire.NewValueBinary(v.IsolationGroupsConfiguration), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 56, Value: w}
		i++
	}
	if v.IsolationGroupsConfigurationEncoding != nil {
		w, err = wire.NewValueString(*(v.IsolationGroupsConfigurationEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 58, Value: w}
		i++
	}
	if v.AsyncWorkflowConfiguration != nil {
		w, err = wire.NewValueBinary(v.AsyncWorkflowConfiguration), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.AsyncWorkflowConfigurationEncoding != nil {
		w, err = wire.NewValueString(*(v.AsyncWorkflowConfigurationEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 62, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a DomainInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DomainInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v DomainInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *DomainInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Description = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Owner = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.RetentionDays = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.EmitMetric = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ArchivalBucket = &x
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.ArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ConfigVersion = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NotificationVersion = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FailoverNotificationVersion = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FailoverVersion = &x
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActiveClusterName = &x
				if err != nil {
					return err
				}

			}
		case 36:
			if field.Value.Type() == wire.TList {
				v.Clusters, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TMap {
				v.Data, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 39:
			if field.Value.Type() == wire.TBinary {
				v.BadBinaries, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BadBinariesEncoding = &x
				if err != nil {
					return err
				}

			}
		case 42:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.HistoryArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 44:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.HistoryArchivalURI = &x
				if err != nil {
					return err
				}

			}
		case 46:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.VisibilityArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 48:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.VisibilityArchivalURI = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FailoverEndTime = &x
				if err != nil {
					return err
				}

			}
		case 52:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.PreviousFailoverVersion = &x
				if err != nil {
					return err
				}

			}
		case 54:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastUpdatedTime = &x
				if err != nil {
					return err
				}

			}
		case 56:
			if field.Value.Type() == wire.TBinary {
				v.IsolationGroupsConfiguration, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 58:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.IsolationGroupsConfigurationEncoding = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				v.AsyncWorkflowConfiguration, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 62:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AsyncWorkflowConfigurationEncoding = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Map_String_String_Encode(val map[string]string, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TBinary,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := sw.WriteString(v); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

// Encode serializes a DomainInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a DomainInfo struct could not be encoded.
func (v *DomainInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Description != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Description)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Owner != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Owner)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Status != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Status)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetentionDays != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.RetentionDays)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EmitMetric != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.EmitMetric)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ArchivalBucket != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ArchivalBucket)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ArchivalStatus != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.ArchivalStatus)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ConfigVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 26, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ConfigVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NotificationVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 28, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.NotificationVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FailoverNotificationVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 30, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.FailoverNotificationVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FailoverVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 32, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.FailoverVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ActiveClusterName != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 34, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ActiveClusterName)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Clusters != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 36, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.Clusters, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Data != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 38, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_String_Encode(v.Data, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.BadBinaries != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 39, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.BadBinaries); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.BadBinariesEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 40, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.BadBinariesEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.HistoryArchivalStatus != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 42, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.HistoryArchivalStatus)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.HistoryArchivalURI != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 44, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.HistoryArchivalURI)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.VisibilityArchivalStatus != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 46, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.VisibilityArchivalStatus)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.VisibilityArchivalURI != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 48, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.VisibilityArchivalURI)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FailoverEndTime != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 50, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.FailoverEndTime)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.PreviousFailoverVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 52, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.PreviousFailoverVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastUpdatedTime != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 54, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastUpdatedTime)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.IsolationGroupsConfiguration != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 56, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.IsolationGroupsConfiguration); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.IsolationGroupsConfigurationEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 58, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.IsolationGroupsConfigurationEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.AsyncWorkflowConfiguration != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 60, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.AsyncWorkflowConfiguration); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.AsyncWorkflowConfigurationEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 62, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.AsyncWorkflowConfigurationEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Map_String_String_Decode(sr stream.Reader) (map[string]string, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TBinary {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string]string, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a DomainInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a DomainInfo struct could not be generated from the wire
// representation.
func (v *DomainInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Description = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Owner = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Status = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.RetentionDays = &x
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.EmitMetric = &x
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ArchivalBucket = &x
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.ArchivalStatus = &x
			if err != nil {
				return err
			}

		case fh.ID == 26 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ConfigVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 28 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.NotificationVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 30 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.FailoverNotificationVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 32 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.FailoverVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 34 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ActiveClusterName = &x
			if err != nil {
				return err
			}

		case fh.ID == 36 && fh.Type == wire.TList:
			v.Clusters, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 38 && fh.Type == wire.TMap:
			v.Data, err = _Map_String_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 39 && fh.Type == wire.TBinary:
			v.BadBinaries, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 40 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.BadBinariesEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 42 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.HistoryArchivalStatus = &x
			if err != nil {
				return err
			}

		case fh.ID == 44 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.HistoryArchivalURI = &x
			if err != nil {
				return err
			}

		case fh.ID == 46 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.VisibilityArchivalStatus = &x
			if err != nil {
				return err
			}

		case fh.ID == 48 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.VisibilityArchivalURI = &x
			if err != nil {
				return err
			}

		case fh.ID == 50 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.FailoverEndTime = &x
			if err != nil {
				return err
			}

		case fh.ID == 52 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.PreviousFailoverVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 54 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastUpdatedTime = &x
			if err != nil {
				return err
			}

		case fh.ID == 56 && fh.Type == wire.TBinary:
			v.IsolationGroupsConfiguration, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 58 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.IsolationGroupsConfigurationEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 60 && fh.Type == wire.TBinary:
			v.AsyncWorkflowConfiguration, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 62 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.AsyncWorkflowConfigurationEncoding = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a DomainInfo
// struct.
func (v *DomainInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [28]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Description != nil {
		fields[i] = fmt.Sprintf("Description: %v", *(v.Description))
		i++
	}
	if v.Owner != nil {
		fields[i] = fmt.Sprintf("Owner: %v", *(v.Owner))
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.RetentionDays != nil {
		fields[i] = fmt.Sprintf("RetentionDays: %v", *(v.RetentionDays))
		i++
	}
	if v.EmitMetric != nil {
		fields[i] = fmt.Sprintf("EmitMetric: %v", *(v.EmitMetric))
		i++
	}
	if v.ArchivalBucket != nil {
		fields[i] = fmt.Sprintf("ArchivalBucket: %v", *(v.ArchivalBucket))
		i++
	}
	if v.ArchivalStatus != nil {
		fields[i] = fmt.Sprintf("ArchivalStatus: %v", *(v.ArchivalStatus))
		i++
	}
	if v.ConfigVersion != nil {
		fields[i] = fmt.Sprintf("ConfigVersion: %v", *(v.ConfigVersion))
		i++
	}
	if v.NotificationVersion != nil {
		fields[i] = fmt.Sprintf("NotificationVersion: %v", *(v.NotificationVersion))
		i++
	}
	if v.FailoverNotificationVersion != nil {
		fields[i] = fmt.Sprintf("FailoverNotificationVersion: %v", *(v.FailoverNotificationVersion))
		i++
	}
	if v.FailoverVersion != nil {
		fields[i] = fmt.Sprintf("FailoverVersion: %v", *(v.FailoverVersion))
		i++
	}
	if v.ActiveClusterName != nil {
		fields[i] = fmt.Sprintf("ActiveClusterName: %v", *(v.ActiveClusterName))
		i++
	}
	if v.Clusters != nil {
		fields[i] = fmt.Sprintf("Clusters: %v", v.Clusters)
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", v.Data)
		i++
	}
	if v.BadBinaries != nil {
		fields[i] = fmt.Sprintf("BadBinaries: %v", v.BadBinaries)
		i++
	}
	if v.BadBinariesEncoding != nil {
		fields[i] = fmt.Sprintf("BadBinariesEncoding: %v", *(v.BadBinariesEncoding))
		i++
	}
	if v.HistoryArchivalStatus != nil {
		fields[i] = fmt.Sprintf("HistoryArchivalStatus: %v", *(v.HistoryArchivalStatus))
		i++
	}
	if v.HistoryArchivalURI != nil {
		fields[i] = fmt.Sprintf("HistoryArchivalURI: %v", *(v.HistoryArchivalURI))
		i++
	}
	if v.VisibilityArchivalStatus != nil {
		fields[i] = fmt.Sprintf("VisibilityArchivalStatus: %v", *(v.VisibilityArchivalStatus))
		i++
	}
	if v.VisibilityArchivalURI != nil {
		fields[i] = fmt.Sprintf("VisibilityArchivalURI: %v", *(v.VisibilityArchivalURI))
		i++
	}
	if v.FailoverEndTime != nil {
		fields[i] = fmt.Sprintf("FailoverEndTime: %v", *(v.FailoverEndTime))
		i++
	}
	if v.PreviousFailoverVersion != nil {
		fields[i] = fmt.Sprintf("PreviousFailoverVersion: %v", *(v.PreviousFailoverVersion))
		i++
	}
	if v.LastUpdatedTime != nil {
		fields[i] = fmt.Sprintf("LastUpdatedTime: %v", *(v.LastUpdatedTime))
		i++
	}
	if v.IsolationGroupsConfiguration != nil {
		fields[i] = fmt.Sprintf("IsolationGroupsConfiguration: %v", v.IsolationGroupsConfiguration)
		i++
	}
	if v.IsolationGroupsConfigurationEncoding != nil {
		fields[i] = fmt.Sprintf("IsolationGroupsConfigurationEncoding: %v", *(v.IsolationGroupsConfigurationEncoding))
		i++
	}
	if v.AsyncWorkflowConfiguration != nil {
		fields[i] = fmt.Sprintf("AsyncWorkflowConfiguration: %v", v.AsyncWorkflowConfiguration)
		i++
	}
	if v.AsyncWorkflowConfigurationEncoding != nil {
		fields[i] = fmt.Sprintf("AsyncWorkflowConfigurationEncoding: %v", *(v.AsyncWorkflowConfigurationEncoding))
		i++
	}

	return fmt.Sprintf("DomainInfo{%v}", strings.Join(fields[:i], ", "))
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this DomainInfo match the
// provided DomainInfo.
//
// This function performs a deep comparison.
func (v *DomainInfo) Equals(rhs *DomainInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Description, rhs.Description) {
		return false
	}
	if !_String_EqualsPtr(v.Owner, rhs.Owner) {
		return false
	}
	if !_I32_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_I16_EqualsPtr(v.RetentionDays, rhs.RetentionDays) {
		return false
	}
	if !_Bool_EqualsPtr(v.EmitMetric, rhs.EmitMetric) {
		return false
	}
	if !_String_EqualsPtr(v.ArchivalBucket, rhs.ArchivalBucket) {
		return false
	}
	if !_I16_EqualsPtr(v.ArchivalStatus, rhs.ArchivalStatus) {
		return false
	}
	if !_I64_EqualsPtr(v.ConfigVersion, rhs.ConfigVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.NotificationVersion, rhs.NotificationVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.FailoverNotificationVersion, rhs.FailoverNotificationVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.FailoverVersion, rhs.FailoverVersion) {
		return false
	}
	if !_String_EqualsPtr(v.ActiveClusterName, rhs.ActiveClusterName) {
		return false
	}
	if !((v.Clusters == nil && rhs.Clusters == nil) || (v.Clusters != nil && rhs.Clusters != nil && _List_String_Equals(v.Clusters, rhs.Clusters))) {
		return false
	}
	if !((v.Data == nil && rhs.Data == nil) || (v.Data != nil && rhs.Data != nil && _Map_String_String_Equals(v.Data, rhs.Data))) {
		return false
	}
	if !((v.BadBinaries == nil && rhs.BadBinaries == nil) || (v.BadBinaries != nil && rhs.BadBinaries != nil && bytes.Equal(v.BadBinaries, rhs.BadBinaries))) {
		return false
	}
	if !_String_EqualsPtr(v.BadBinariesEncoding, rhs.BadBinariesEncoding) {
		return false
	}
	if !_I16_EqualsPtr(v.HistoryArchivalStatus, rhs.HistoryArchivalStatus) {
		return false
	}
	if !_String_EqualsPtr(v.HistoryArchivalURI, rhs.HistoryArchivalURI) {
		return false
	}
	if !_I16_EqualsPtr(v.VisibilityArchivalStatus, rhs.VisibilityArchivalStatus) {
		return false
	}
	if !_String_EqualsPtr(v.VisibilityArchivalURI, rhs.VisibilityArchivalURI) {
		return false
	}
	if !_I64_EqualsPtr(v.FailoverEndTime, rhs.FailoverEndTime) {
		return false
	}
	if !_I64_EqualsPtr(v.PreviousFailoverVersion, rhs.PreviousFailoverVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.LastUpdatedTime, rhs.LastUpdatedTime) {
		return false
	}
	if !((v.IsolationGroupsConfiguration == nil && rhs.IsolationGroupsConfiguration == nil) || (v.IsolationGroupsConfiguration != nil && rhs.IsolationGroupsConfiguration != nil && bytes.Equal(v.IsolationGroupsConfiguration, rhs.IsolationGroupsConfiguration))) {
		return false
	}
	if !_String_EqualsPtr(v.IsolationGroupsConfigurationEncoding, rhs.IsolationGroupsConfigurationEncoding) {
		return false
	}
	if !((v.AsyncWorkflowConfiguration == nil && rhs.AsyncWorkflowConfiguration == nil) || (v.AsyncWorkflowConfiguration != nil && rhs.AsyncWorkflowConfiguration != nil && bytes.Equal(v.AsyncWorkflowConfiguration, rhs.AsyncWorkflowConfiguration))) {
		return false
	}
	if !_String_EqualsPtr(v.AsyncWorkflowConfigurationEncoding, rhs.AsyncWorkflowConfigurationEncoding) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DomainInfo.
func (v *DomainInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Description != nil {
		enc.AddString("description", *v.Description)
	}
	if v.Owner != nil {
		enc.AddString("owner", *v.Owner)
	}
	if v.Status != nil {
		enc.AddInt32("status", *v.Status)
	}
	if v.RetentionDays != nil {
		enc.AddInt16("retentionDays", *v.RetentionDays)
	}
	if v.EmitMetric != nil {
		enc.AddBool("emitMetric", *v.EmitMetric)
	}
	if v.ArchivalBucket != nil {
		enc.AddString("archivalBucket", *v.ArchivalBucket)
	}
	if v.ArchivalStatus != nil {
		enc.AddInt16("archivalStatus", *v.ArchivalStatus)
	}
	if v.ConfigVersion != nil {
		enc.AddInt64("configVersion", *v.ConfigVersion)
	}
	if v.NotificationVersion != nil {
		enc.AddInt64("notificationVersion", *v.NotificationVersion)
	}
	if v.FailoverNotificationVersion != nil {
		enc.AddInt64("failoverNotificationVersion", *v.FailoverNotificationVersion)
	}
	if v.FailoverVersion != nil {
		enc.AddInt64("failoverVersion", *v.FailoverVersion)
	}
	if v.ActiveClusterName != nil {
		enc.AddString("activeClusterName", *v.ActiveClusterName)
	}
	if v.Clusters != nil {
		err = multierr.Append(err, enc.AddArray("clusters", (_List_String_Zapper)(v.Clusters)))
	}
	if v.Data != nil {
		err = multierr.Append(err, enc.AddObject("data", (_Map_String_String_Zapper)(v.Data)))
	}
	if v.BadBinaries != nil {
		enc.AddString("badBinaries", base64.StdEncoding.EncodeToString(v.BadBinaries))
	}
	if v.BadBinariesEncoding != nil {
		enc.AddString("badBinariesEncoding", *v.BadBinariesEncoding)
	}
	if v.HistoryArchivalStatus != nil {
		enc.AddInt16("historyArchivalStatus", *v.HistoryArchivalStatus)
	}
	if v.HistoryArchivalURI != nil {
		enc.AddString("historyArchivalURI", *v.HistoryArchivalURI)
	}
	if v.VisibilityArchivalStatus != nil {
		enc.AddInt16("visibilityArchivalStatus", *v.VisibilityArchivalStatus)
	}
	if v.VisibilityArchivalURI != nil {
		enc.AddString("visibilityArchivalURI", *v.VisibilityArchivalURI)
	}
	if v.FailoverEndTime != nil {
		enc.AddInt64("failoverEndTime", *v.FailoverEndTime)
	}
	if v.PreviousFailoverVersion != nil {
		enc.AddInt64("previousFailoverVersion", *v.PreviousFailoverVersion)
	}
	if v.LastUpdatedTime != nil {
		enc.AddInt64("lastUpdatedTime", *v.LastUpdatedTime)
	}
	if v.IsolationGroupsConfiguration != nil {
		enc.AddString("isolationGroupsConfiguration", base64.StdEncoding.EncodeToString(v.IsolationGroupsConfiguration))
	}
	if v.IsolationGroupsConfigurationEncoding != nil {
		enc.AddString("isolationGroupsConfigurationEncoding", *v.IsolationGroupsConfigurationEncoding)
	}
	if v.AsyncWorkflowConfiguration != nil {
		enc.AddString("asyncWorkflowConfiguration", base64.StdEncoding.EncodeToString(v.AsyncWorkflowConfiguration))
	}
	if v.AsyncWorkflowConfigurationEncoding != nil {
		enc.AddString("asyncWorkflowConfigurationEncoding", *v.AsyncWorkflowConfigurationEncoding)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *DomainInfo) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetDescription returns the value of Description if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetDescription() (o string) {
	if v != nil && v.Description != nil {
		return *v.Description
	}

	return
}

// IsSetDescription returns true if Description is not nil.
func (v *DomainInfo) IsSetDescription() bool {
	return v != nil && v.Description != nil
}

// GetOwner returns the value of Owner if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetOwner() (o string) {
	if v != nil && v.Owner != nil {
		return *v.Owner
	}

	return
}

// IsSetOwner returns true if Owner is not nil.
func (v *DomainInfo) IsSetOwner() bool {
	return v != nil && v.Owner != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetStatus() (o int32) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *DomainInfo) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetRetentionDays returns the value of RetentionDays if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetRetentionDays() (o int16) {
	if v != nil && v.RetentionDays != nil {
		return *v.RetentionDays
	}

	return
}

// IsSetRetentionDays returns true if RetentionDays is not nil.
func (v *DomainInfo) IsSetRetentionDays() bool {
	return v != nil && v.RetentionDays != nil
}

// GetEmitMetric returns the value of EmitMetric if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetEmitMetric() (o bool) {
	if v != nil && v.EmitMetric != nil {
		return *v.EmitMetric
	}

	return
}

// IsSetEmitMetric returns true if EmitMetric is not nil.
func (v *DomainInfo) IsSetEmitMetric() bool {
	return v != nil && v.EmitMetric != nil
}

// GetArchivalBucket returns the value of ArchivalBucket if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetArchivalBucket() (o string) {
	if v != nil && v.ArchivalBucket != nil {
		return *v.ArchivalBucket
	}

	return
}

// IsSetArchivalBucket returns true if ArchivalBucket is not nil.
func (v *DomainInfo) IsSetArchivalBucket() bool {
	return v != nil && v.ArchivalBucket != nil
}

// GetArchivalStatus returns the value of ArchivalStatus if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetArchivalStatus() (o int16) {
	if v != nil && v.ArchivalStatus != nil {
		return *v.ArchivalStatus
	}

	return
}

// IsSetArchivalStatus returns true if ArchivalStatus is not nil.
func (v *DomainInfo) IsSetArchivalStatus() bool {
	return v != nil && v.ArchivalStatus != nil
}

// GetConfigVersion returns the value of ConfigVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetConfigVersion() (o int64) {
	if v != nil && v.ConfigVersion != nil {
		return *v.ConfigVersion
	}

	return
}

// IsSetConfigVersion returns true if ConfigVersion is not nil.
func (v *DomainInfo) IsSetConfigVersion() bool {
	return v != nil && v.ConfigVersion != nil
}

// GetNotificationVersion returns the value of NotificationVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetNotificationVersion() (o int64) {
	if v != nil && v.NotificationVersion != nil {
		return *v.NotificationVersion
	}

	return
}

// IsSetNotificationVersion returns true if NotificationVersion is not nil.
func (v *DomainInfo) IsSetNotificationVersion() bool {
	return v != nil && v.NotificationVersion != nil
}

// GetFailoverNotificationVersion returns the value of FailoverNotificationVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetFailoverNotificationVersion() (o int64) {
	if v != nil && v.FailoverNotificationVersion != nil {
		return *v.FailoverNotificationVersion
	}

	return
}

// IsSetFailoverNotificationVersion returns true if FailoverNotificationVersion is not nil.
func (v *DomainInfo) IsSetFailoverNotificationVersion() bool {
	return v != nil && v.FailoverNotificationVersion != nil
}

// GetFailoverVersion returns the value of FailoverVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetFailoverVersion() (o int64) {
	if v != nil && v.FailoverVersion != nil {
		return *v.FailoverVersion
	}

	return
}

// IsSetFailoverVersion returns true if FailoverVersion is not nil.
func (v *DomainInfo) IsSetFailoverVersion() bool {
	return v != nil && v.FailoverVersion != nil
}

// GetActiveClusterName returns the value of ActiveClusterName if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetActiveClusterName() (o string) {
	if v != nil && v.ActiveClusterName != nil {
		return *v.ActiveClusterName
	}

	return
}

// IsSetActiveClusterName returns true if ActiveClusterName is not nil.
func (v *DomainInfo) IsSetActiveClusterName() bool {
	return v != nil && v.ActiveClusterName != nil
}

// GetClusters returns the value of Clusters if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetClusters() (o []string) {
	if v != nil && v.Clusters != nil {
		return v.Clusters
	}

	return
}

// IsSetClusters returns true if Clusters is not nil.
func (v *DomainInfo) IsSetClusters() bool {
	return v != nil && v.Clusters != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetData() (o map[string]string) {
	if v != nil && v.Data != nil {
		return v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *DomainInfo) IsSetData() bool {
	return v != nil && v.Data != nil
}

// GetBadBinaries returns the value of BadBinaries if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetBadBinaries() (o []byte) {
	if v != nil && v.BadBinaries != nil {
		return v.BadBinaries
	}

	return
}

// IsSetBadBinaries returns true if BadBinaries is not nil.
func (v *DomainInfo) IsSetBadBinaries() bool {
	return v != nil && v.BadBinaries != nil
}

// GetBadBinariesEncoding returns the value of BadBinariesEncoding if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetBadBinariesEncoding() (o string) {
	if v != nil && v.BadBinariesEncoding != nil {
		return *v.BadBinariesEncoding
	}

	return
}

// IsSetBadBinariesEncoding returns true if BadBinariesEncoding is not nil.
func (v *DomainInfo) IsSetBadBinariesEncoding() bool {
	return v != nil && v.BadBinariesEncoding != nil
}

// GetHistoryArchivalStatus returns the value of HistoryArchivalStatus if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetHistoryArchivalStatus() (o int16) {
	if v != nil && v.HistoryArchivalStatus != nil {
		return *v.HistoryArchivalStatus
	}

	return
}

// IsSetHistoryArchivalStatus returns true if HistoryArchivalStatus is not nil.
func (v *DomainInfo) IsSetHistoryArchivalStatus() bool {
	return v != nil && v.HistoryArchivalStatus != nil
}

// GetHistoryArchivalURI returns the value of HistoryArchivalURI if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetHistoryArchivalURI() (o string) {
	if v != nil && v.HistoryArchivalURI != nil {
		return *v.HistoryArchivalURI
	}

	return
}

// IsSetHistoryArchivalURI returns true if HistoryArchivalURI is not nil.
func (v *DomainInfo) IsSetHistoryArchivalURI() bool {
	return v != nil && v.HistoryArchivalURI != nil
}

// GetVisibilityArchivalStatus returns the value of VisibilityArchivalStatus if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetVisibilityArchivalStatus() (o int16) {
	if v != nil && v.VisibilityArchivalStatus != nil {
		return *v.VisibilityArchivalStatus
	}

	return
}

// IsSetVisibilityArchivalStatus returns true if VisibilityArchivalStatus is not nil.
func (v *DomainInfo) IsSetVisibilityArchivalStatus() bool {
	return v != nil && v.VisibilityArchivalStatus != nil
}

// GetVisibilityArchivalURI returns the value of VisibilityArchivalURI if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetVisibilityArchivalURI() (o string) {
	if v != nil && v.VisibilityArchivalURI != nil {
		return *v.VisibilityArchivalURI
	}

	return
}

// IsSetVisibilityArchivalURI returns true if VisibilityArchivalURI is not nil.
func (v *DomainInfo) IsSetVisibilityArchivalURI() bool {
	return v != nil && v.VisibilityArchivalURI != nil
}

// GetFailoverEndTime returns the value of FailoverEndTime if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetFailoverEndTime() (o int64) {
	if v != nil && v.FailoverEndTime != nil {
		return *v.FailoverEndTime
	}

	return
}

// IsSetFailoverEndTime returns true if FailoverEndTime is not nil.
func (v *DomainInfo) IsSetFailoverEndTime() bool {
	return v != nil && v.FailoverEndTime != nil
}

// GetPreviousFailoverVersion returns the value of PreviousFailoverVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetPreviousFailoverVersion() (o int64) {
	if v != nil && v.PreviousFailoverVersion != nil {
		return *v.PreviousFailoverVersion
	}

	return
}

// IsSetPreviousFailoverVersion returns true if PreviousFailoverVersion is not nil.
func (v *DomainInfo) IsSetPreviousFailoverVersion() bool {
	return v != nil && v.PreviousFailoverVersion != nil
}

// GetLastUpdatedTime returns the value of LastUpdatedTime if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetLastUpdatedTime() (o int64) {
	if v != nil && v.LastUpdatedTime != nil {
		return *v.LastUpdatedTime
	}

	return
}

// IsSetLastUpdatedTime returns true if LastUpdatedTime is not nil.
func (v *DomainInfo) IsSetLastUpdatedTime() bool {
	return v != nil && v.LastUpdatedTime != nil
}

// GetIsolationGroupsConfiguration returns the value of IsolationGroupsConfiguration if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetIsolationGroupsConfiguration() (o []byte) {
	if v != nil && v.IsolationGroupsConfiguration != nil {
		return v.IsolationGroupsConfiguration
	}

	return
}

// IsSetIsolationGroupsConfiguration returns true if IsolationGroupsConfiguration is not nil.
func (v *DomainInfo) IsSetIsolationGroupsConfiguration() bool {
	return v != nil && v.IsolationGroupsConfiguration != nil
}

// GetIsolationGroupsConfigurationEncoding returns the value of IsolationGroupsConfigurationEncoding if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetIsolationGroupsConfigurationEncoding() (o string) {
	if v != nil && v.IsolationGroupsConfigurationEncoding != nil {
		return *v.IsolationGroupsConfigurationEncoding
	}

	return
}

// IsSetIsolationGroupsConfigurationEncoding returns true if IsolationGroupsConfigurationEncoding is not nil.
func (v *DomainInfo) IsSetIsolationGroupsConfigurationEncoding() bool {
	return v != nil && v.IsolationGroupsConfigurationEncoding != nil
}

// GetAsyncWorkflowConfiguration returns the value of AsyncWorkflowConfiguration if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetAsyncWorkflowConfiguration() (o []byte) {
	if v != nil && v.AsyncWorkflowConfiguration != nil {
		return v.AsyncWorkflowConfiguration
	}

	return
}

// IsSetAsyncWorkflowConfiguration returns true if AsyncWorkflowConfiguration is not nil.
func (v *DomainInfo) IsSetAsyncWorkflowConfiguration() bool {
	return v != nil && v.AsyncWorkflowConfiguration != nil
}

// GetAsyncWorkflowConfigurationEncoding returns the value of AsyncWorkflowConfigurationEncoding if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetAsyncWorkflowConfigurationEncoding() (o string) {
	if v != nil && v.AsyncWorkflowConfigurationEncoding != nil {
		return *v.AsyncWorkflowConfigurationEncoding
	}

	return
}

// IsSetAsyncWorkflowConfigurationEncoding returns true if AsyncWorkflowConfigurationEncoding is not nil.
func (v *DomainInfo) IsSetAsyncWorkflowConfigurationEncoding() bool {
	return v != nil && v.AsyncWorkflowConfigurationEncoding != nil
}

type HistoryTreeInfo struct {
	CreatedTimeNanos *int64                       `json:"createdTimeNanos,omitempty"`
	Ancestors        []*shared.HistoryBranchRange `json:"ancestors,omitempty"`
	Info             *string                      `json:"info,omitempty"`
}

type _List_HistoryBranchRange_ValueList []*shared.HistoryBranchRange

func (v _List_HistoryBranchRange_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]*shared.HistoryBranchRange', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_HistoryBranchRange_ValueList) Size() int {
	return len(v)
}

func (_List_HistoryBranchRange_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_HistoryBranchRange_ValueList) Close() {}

// ToWire translates a HistoryTreeInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *HistoryTreeInfo) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.CreatedTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.CreatedTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Ancestors != nil {
		w, err = wire.NewValueList(_List_HistoryBranchRange_ValueList(v.Ancestors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.Info != nil {
		w, err = wire.NewValueString(*(v.Info)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _HistoryBranchRange_Read(w wire.Value) (*shared.HistoryBranchRange, error) {
	var v shared.HistoryBranchRange
	err := v.FromWire(w)
	return &v, err
}

func _List_HistoryBranchRange_Read(l wire.ValueList) ([]*shared.HistoryBranchRange, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*shared.HistoryBranchRange, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _HistoryBranchRange_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a HistoryTreeInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HistoryTreeInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v HistoryTreeInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *HistoryTreeInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CreatedTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TList {
				v.Ancestors, err = _List_HistoryBranchRange_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Info = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_HistoryBranchRange_Encode(val []*shared.HistoryBranchRange, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]*shared.HistoryBranchRange', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a HistoryTreeInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a HistoryTreeInfo struct could not be encoded.
func (v *HistoryTreeInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.CreatedTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.CreatedTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Ancestors != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_HistoryBranchRange_Encode(v.Ancestors, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Info != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Info)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _HistoryBranchRange_Decode(sr stream.Reader) (*shared.HistoryBranchRange, error) {
	var v shared.HistoryBranchRange
	err := v.Decode(sr)
	return &v, err
}

func _List_HistoryBranchRange_Decode(sr stream.Reader) ([]*shared.HistoryBranchRange, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TStruct {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]*shared.HistoryBranchRange, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _HistoryBranchRange_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a HistoryTreeInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a HistoryTreeInfo struct could not be generated from the wire
// representation.
func (v *HistoryTreeInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.CreatedTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TList:
			v.Ancestors, err = _List_HistoryBranchRange_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Info = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a HistoryTreeInfo
// struct.
func (v *HistoryTreeInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.CreatedTimeNanos != nil {
		fields[i] = fmt.Sprintf("CreatedTimeNanos: %v", *(v.CreatedTimeNanos))
		i++
	}
	if v.Ancestors != nil {
		fields[i] = fmt.Sprintf("Ancestors: %v", v.Ancestors)
		i++
	}
	if v.Info != nil {
		fields[i] = fmt.Sprintf("Info: %v", *(v.Info))
		i++
	}

	return fmt.Sprintf("HistoryTreeInfo{%v}", strings.Join(fields[:i], ", "))
}

func _List_HistoryBranchRange_Equals(lhs, rhs []*shared.HistoryBranchRange) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this HistoryTreeInfo match the
// provided HistoryTreeInfo.
//
// This function performs a deep comparison.
func (v *HistoryTreeInfo) Equals(rhs *HistoryTreeInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.CreatedTimeNanos, rhs.CreatedTimeNanos) {
		return false
	}
	if !((v.Ancestors == nil && rhs.Ancestors == nil) || (v.Ancestors != nil && rhs.Ancestors != nil && _List_HistoryBranchRange_Equals(v.Ancestors, rhs.Ancestors))) {
		return false
	}
	if !_String_EqualsPtr(v.Info, rhs.Info) {
		return false
	}

	return true
}

type _List_HistoryBranchRange_Zapper []*shared.HistoryBranchRange

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_HistoryBranchRange_Zapper.
func (l _List_HistoryBranchRange_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HistoryTreeInfo.
func (v *HistoryTreeInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.CreatedTimeNanos != nil {
		enc.AddInt64("createdTimeNanos", *v.CreatedTimeNanos)
	}
	if v.Ancestors != nil {
		err = multierr.Append(err, enc.AddArray("ancestors", (_List_HistoryBranchRange_Zapper)(v.Ancestors)))
	}
	if v.Info != nil {
		enc.AddString("info", *v.Info)
	}
	return err
}

// GetCreatedTimeNanos returns the value of CreatedTimeNanos if it is set or its
// zero value if it is unset.
func (v *HistoryTreeInfo) GetCreatedTimeNanos() (o int64) {
	if v != nil && v.CreatedTimeNanos != nil {
		return *v.CreatedTimeNanos
	}

	return
}

// IsSetCreatedTimeNanos returns true if CreatedTimeNanos is not nil.
func (v *HistoryTreeInfo) IsSetCreatedTimeNanos() bool {
	return v != nil && v.CreatedTimeNanos != nil
}

// GetAncestors returns the value of Ancestors if it is set or its
// zero value if it is unset.
func (v *HistoryTreeInfo) GetAncestors() (o []*shared.HistoryBranchRange) {
	if v != nil && v.Ancestors != nil {
		return v.Ancestors
	}

	return
}

// IsSetAncestors returns true if Ancestors is not nil.
func (v *HistoryTreeInfo) IsSetAncestors() bool {
	return v != nil && v.Ancestors != nil
}

// GetInfo returns the value of Info if it is set or its
// zero value if it is unset.
func (v *HistoryTreeInfo) GetInfo() (o string) {
	if v != nil && v.Info != nil {
		return *v.Info
	}

	return
}

// IsSetInfo returns true if Info is not nil.
func (v *HistoryTreeInfo) IsSetInfo() bool {
	return v != nil && v.Info != nil
}

type ReplicationTaskInfo struct {
	DomainID                []byte  `json:"domainID,omitempty"`
	WorkflowID              *string `json:"workflowID,omitempty"`
	RunID                   []byte  `json:"runID,omitempty"`
	TaskType                *int16  `json:"taskType,omitempty"`
	Version                 *int64  `json:"version,omitempty"`
	FirstEventID            *int64  `json:"firstEventID,omitempty"`
	NextEventID             *int64  `json:"nextEventID,omitempty"`
	ScheduledID             *int64  `json:"scheduledID,omitempty"`
	EventStoreVersion       *int32  `json:"eventStoreVersion,omitempty"`
	NewRunEventStoreVersion *int32  `json:"newRunEventStoreVersion,omitempty"`
	BranchToken             []byte  `json:"branch_token,omitempty"`
	NewRunBranchToken       []byte  `json:"newRunBranchToken,omitempty"`
	CreationTime            *int64  `json:"creationTime,omitempty"`
}

// ToWire translates a ReplicationTaskInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *ReplicationTaskInfo) ToWire() (wire.Value, error) {
	var (
		fields [13]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.DomainID != nil {
		w, err = wire.NewValueBinary(v.DomainID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueBinary(v.RunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.TaskType != nil {
		w, err = wire.NewValueI16(*(v.TaskType)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.FirstEventID != nil {
		w, err = wire.NewValueI64(*(v.FirstEventID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.NextEventID != nil {
		w, err = wire.NewValueI64(*(v.NextEventID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.ScheduledID != nil {
		w, err = wire.NewValueI64(*(v.ScheduledID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.EventStoreVersion != nil {
		w, err = wire.NewValueI32(*(v.EventStoreVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.NewRunEventStoreVersion != nil {
		w, err = wire.NewValueI32(*(v.NewRunEventStoreVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.BranchToken != nil {
		w, err = wire.NewValueBinary(v.BranchToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.NewRunBranchToken != nil {
		w, err = wire.NewValueBinary(v.NewRunBranchToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.CreationTime != nil {
		w, err = wire.NewValueI64(*(v.CreationTime)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ReplicationTaskInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ReplicationTaskInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v ReplicationTaskInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *ReplicationTaskInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.DomainID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				v.RunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.TaskType = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FirstEventID = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NextEventID = &x
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduledID = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EventStoreVersion = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.NewRunEventStoreVersion = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.BranchToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TBinary {
				v.NewRunBranchToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CreationTime = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ReplicationTaskInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ReplicationTaskInfo struct could not be encoded.
func (v *ReplicationTaskInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.DomainID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.DomainID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.WorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.RunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskType != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.TaskType)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FirstEventID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.FirstEventID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NextEventID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.NextEventID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduledID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ScheduledID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EventStoreVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 26, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.EventStoreVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NewRunEventStoreVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 28, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.NewRunEventStoreVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.BranchToken != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 30, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.BranchToken); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NewRunBranchToken != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 34, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.NewRunBranchToken); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CreationTime != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 38, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.CreationTime)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ReplicationTaskInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ReplicationTaskInfo struct could not be generated from the wire
// representation.
func (v *ReplicationTaskInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			v.DomainID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.WorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			v.RunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.TaskType = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.FirstEventID = &x
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.NextEventID = &x
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ScheduledID = &x
			if err != nil {
				return err
			}

		case fh.ID == 26 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.EventStoreVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 28 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.NewRunEventStoreVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 30 && fh.Type == wire.TBinary:
			v.BranchToken, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 34 && fh.Type == wire.TBinary:
			v.NewRunBranchToken, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 38 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.CreationTime = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ReplicationTaskInfo
// struct.
func (v *ReplicationTaskInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [13]string
	i := 0
	if v.DomainID != nil {
		fields[i] = fmt.Sprintf("DomainID: %v", v.DomainID)
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", v.RunID)
		i++
	}
	if v.TaskType != nil {
		fields[i] = fmt.Sprintf("TaskType: %v", *(v.TaskType))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.FirstEventID != nil {
		fields[i] = fmt.Sprintf("FirstEventID: %v", *(v.FirstEventID))
		i++
	}
	if v.NextEventID != nil {
		fields[i] = fmt.Sprintf("NextEventID: %v", *(v.NextEventID))
		i++
	}
	if v.ScheduledID != nil {
		fields[i] = fmt.Sprintf("ScheduledID: %v", *(v.ScheduledID))
		i++
	}
	if v.EventStoreVersion != nil {
		fields[i] = fmt.Sprintf("EventStoreVersion: %v", *(v.EventStoreVersion))
		i++
	}
	if v.NewRunEventStoreVersion != nil {
		fields[i] = fmt.Sprintf("NewRunEventStoreVersion: %v", *(v.NewRunEventStoreVersion))
		i++
	}
	if v.BranchToken != nil {
		fields[i] = fmt.Sprintf("BranchToken: %v", v.BranchToken)
		i++
	}
	if v.NewRunBranchToken != nil {
		fields[i] = fmt.Sprintf("NewRunBranchToken: %v", v.NewRunBranchToken)
		i++
	}
	if v.CreationTime != nil {
		fields[i] = fmt.Sprintf("CreationTime: %v", *(v.CreationTime))
		i++
	}

	return fmt.Sprintf("ReplicationTaskInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ReplicationTaskInfo match the
// provided ReplicationTaskInfo.
//
// This function performs a deep comparison.
func (v *ReplicationTaskInfo) Equals(rhs *ReplicationTaskInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.DomainID == nil && rhs.DomainID == nil) || (v.DomainID != nil && rhs.DomainID != nil && bytes.Equal(v.DomainID, rhs.DomainID))) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !((v.RunID == nil && rhs.RunID == nil) || (v.RunID != nil && rhs.RunID != nil && bytes.Equal(v.RunID, rhs.RunID))) {
		return false
	}
	if !_I16_EqualsPtr(v.TaskType, rhs.TaskType) {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.FirstEventID, rhs.FirstEventID) {
		return false
	}
	if !_I64_EqualsPtr(v.NextEventID, rhs.NextEventID) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduledID, rhs.ScheduledID) {
		return false
	}
	if !_I32_EqualsPtr(v.EventStoreVersion, rhs.EventStoreVersion) {
		return false
	}
	if !_I32_EqualsPtr(v.NewRunEventStoreVersion, rhs.NewRunEventStoreVersion) {
		return false
	}
	if !((v.BranchToken == nil && rhs.BranchToken == nil) || (v.BranchToken != nil && rhs.BranchToken != nil && bytes.Equal(v.BranchToken, rhs.BranchToken))) {
		return false
	}
	if !((v.NewRunBranchToken == nil && rhs.NewRunBranchToken == nil) || (v.NewRunBranchToken != nil && rhs.NewRunBranchToken != nil && bytes.Equal(v.NewRunBranchToken, rhs.NewRunBranchToken))) {
		return false
	}
	if !_I64_EqualsPtr(v.CreationTime, rhs.CreationTime) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ReplicationTaskInfo.
func (v *ReplicationTaskInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.DomainID != nil {
		enc.AddString("domainID", base64.StdEncoding.EncodeToString(v.DomainID))
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", base64.StdEncoding.EncodeToString(v.RunID))
	}
	if v.TaskType != nil {
		enc.AddInt16("taskType", *v.TaskType)
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.FirstEventID != nil {
		enc.AddInt64("firstEventID", *v.FirstEventID)
	}
	if v.NextEventID != nil {
		enc.AddInt64("nextEventID", *v.NextEventID)
	}
	if v.ScheduledID != nil {
		enc.AddInt64("scheduledID", *v.ScheduledID)
	}
	if v.EventStoreVersion != nil {
		enc.AddInt32("eventStoreVersion", *v.EventStoreVersion)
	}
	if v.NewRunEventStoreVersion != nil {
		enc.AddInt32("newRunEventStoreVersion", *v.NewRunEventStoreVersion)
	}
	if v.BranchToken != nil {
		enc.AddString("branch_token", base64.StdEncoding.EncodeToString(v.BranchToken))
	}
	if v.NewRunBranchToken != nil {
		enc.AddString("newRunBranchToken", base64.StdEncoding.EncodeToString(v.NewRunBranchToken))
	}
	if v.CreationTime != nil {
		enc.AddInt64("creationTime", *v.CreationTime)
	}
	return err
}

// GetDomainID returns the value of DomainID if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetDomainID() (o []byte) {
	if v != nil && v.DomainID != nil {
		return v.DomainID
	}

	return
}

// IsSetDomainID returns true if DomainID is not nil.
func (v *ReplicationTaskInfo) IsSetDomainID() bool {
	return v != nil && v.DomainID != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *ReplicationTaskInfo) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetRunID() (o []byte) {
	if v != nil && v.RunID != nil {
		return v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *ReplicationTaskInfo) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetTaskType returns the value of TaskType if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetTaskType() (o int16) {
	if v != nil && v.TaskType != nil {
		return *v.TaskType
	}

	return
}

// IsSetTaskType returns true if TaskType is not nil.
func (v *ReplicationTaskInfo) IsSetTaskType() bool {
	return v != nil && v.TaskType != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *ReplicationTaskInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetFirstEventID returns the value of FirstEventID if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetFirstEventID() (o int64) {
	if v != nil && v.FirstEventID != nil {
		return *v.FirstEventID
	}

	return
}

// IsSetFirstEventID returns true if FirstEventID is not nil.
func (v *ReplicationTaskInfo) IsSetFirstEventID() bool {
	return v != nil && v.FirstEventID != nil
}

// GetNextEventID returns the value of NextEventID if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetNextEventID() (o int64) {
	if v != nil && v.NextEventID != nil {
		return *v.NextEventID
	}

	return
}

// IsSetNextEventID returns true if NextEventID is not nil.
func (v *ReplicationTaskInfo) IsSetNextEventID() bool {
	return v != nil && v.NextEventID != nil
}

// GetScheduledID returns the value of ScheduledID if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetScheduledID() (o int64) {
	if v != nil && v.ScheduledID != nil {
		return *v.ScheduledID
	}

	return
}

// IsSetScheduledID returns true if ScheduledID is not nil.
func (v *ReplicationTaskInfo) IsSetScheduledID() bool {
	return v != nil && v.ScheduledID != nil
}

// GetEventStoreVersion returns the value of EventStoreVersion if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetEventStoreVersion() (o int32) {
	if v != nil && v.EventStoreVersion != nil {
		return *v.EventStoreVersion
	}

	return
}

// IsSetEventStoreVersion returns true if EventStoreVersion is not nil.
func (v *ReplicationTaskInfo) IsSetEventStoreVersion() bool {
	return v != nil && v.EventStoreVersion != nil
}

// GetNewRunEventStoreVersion returns the value of NewRunEventStoreVersion if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetNewRunEventStoreVersion() (o int32) {
	if v != nil && v.NewRunEventStoreVersion != nil {
		return *v.NewRunEventStoreVersion
	}

	return
}

// IsSetNewRunEventStoreVersion returns true if NewRunEventStoreVersion is not nil.
func (v *ReplicationTaskInfo) IsSetNewRunEventStoreVersion() bool {
	return v != nil && v.NewRunEventStoreVersion != nil
}

// GetBranchToken returns the value of BranchToken if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetBranchToken() (o []byte) {
	if v != nil && v.BranchToken != nil {
		return v.BranchToken
	}

	return
}

// IsSetBranchToken returns true if BranchToken is not nil.
func (v *ReplicationTaskInfo) IsSetBranchToken() bool {
	return v != nil && v.BranchToken != nil
}

// GetNewRunBranchToken returns the value of NewRunBranchToken if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetNewRunBranchToken() (o []byte) {
	if v != nil && v.NewRunBranchToken != nil {
		return v.NewRunBranchToken
	}

	return
}

// IsSetNewRunBranchToken returns true if NewRunBranchToken is not nil.
func (v *ReplicationTaskInfo) IsSetNewRunBranchToken() bool {
	return v != nil && v.NewRunBranchToken != nil
}

// GetCreationTime returns the value of CreationTime if it is set or its
// zero value if it is unset.
func (v *ReplicationTaskInfo) GetCreationTime() (o int64) {
	if v != nil && v.CreationTime != nil {
		return *v.CreationTime
	}

	return
}

// IsSetCreationTime returns true if CreationTime is not nil.
func (v *ReplicationTaskInfo) IsSetCreationTime() bool {
	return v != nil && v.CreationTime != nil
}

type RequestCancelInfo struct {
	Version               *int64  `json:"version,omitempty"`
	InitiatedEventBatchID *int64  `json:"initiatedEventBatchID,omitempty"`
	CancelRequestID       *string `json:"cancelRequestID,omitempty"`
}

// ToWire translates a RequestCancelInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *RequestCancelInfo) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.InitiatedEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.InitiatedEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.CancelRequestID != nil {
		w, err = wire.NewValueString(*(v.CancelRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RequestCancelInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RequestCancelInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v RequestCancelInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *RequestCancelInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.InitiatedEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CancelRequestID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a RequestCancelInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RequestCancelInfo struct could not be encoded.
func (v *RequestCancelInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.InitiatedEventBatchID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 11, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.InitiatedEventBatchID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CancelRequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CancelRequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a RequestCancelInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RequestCancelInfo struct could not be generated from the wire
// representation.
func (v *RequestCancelInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 11 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.InitiatedEventBatchID = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CancelRequestID = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a RequestCancelInfo
// struct.
func (v *RequestCancelInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.InitiatedEventBatchID != nil {
		fields[i] = fmt.Sprintf("InitiatedEventBatchID: %v", *(v.InitiatedEventBatchID))
		i++
	}
	if v.CancelRequestID != nil {
		fields[i] = fmt.Sprintf("CancelRequestID: %v", *(v.CancelRequestID))
		i++
	}

	return fmt.Sprintf("RequestCancelInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RequestCancelInfo match the
// provided RequestCancelInfo.
//
// This function performs a deep comparison.
func (v *RequestCancelInfo) Equals(rhs *RequestCancelInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.InitiatedEventBatchID, rhs.InitiatedEventBatchID) {
		return false
	}
	if !_String_EqualsPtr(v.CancelRequestID, rhs.CancelRequestID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RequestCancelInfo.
func (v *RequestCancelInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.InitiatedEventBatchID != nil {
		enc.AddInt64("initiatedEventBatchID", *v.InitiatedEventBatchID)
	}
	if v.CancelRequestID != nil {
		enc.AddString("cancelRequestID", *v.CancelRequestID)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *RequestCancelInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *RequestCancelInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetInitiatedEventBatchID returns the value of InitiatedEventBatchID if it is set or its
// zero value if it is unset.
func (v *RequestCancelInfo) GetInitiatedEventBatchID() (o int64) {
	if v != nil && v.InitiatedEventBatchID != nil {
		return *v.InitiatedEventBatchID
	}

	return
}

// IsSetInitiatedEventBatchID returns true if InitiatedEventBatchID is not nil.
func (v *RequestCancelInfo) IsSetInitiatedEventBatchID() bool {
	return v != nil && v.InitiatedEventBatchID != nil
}

// GetCancelRequestID returns the value of CancelRequestID if it is set or its
// zero value if it is unset.
func (v *RequestCancelInfo) GetCancelRequestID() (o string) {
	if v != nil && v.CancelRequestID != nil {
		return *v.CancelRequestID
	}

	return
}

// IsSetCancelRequestID returns true if CancelRequestID is not nil.
func (v *RequestCancelInfo) IsSetCancelRequestID() bool {
	return v != nil && v.CancelRequestID != nil
}

type ShardInfo struct {
	StolenSinceRenew                          *int32                       `json:"stolenSinceRenew,omitempty"`
	UpdatedAtNanos                            *int64                       `json:"updatedAtNanos,omitempty"`
	ReplicationAckLevel                       *int64                       `json:"replicationAckLevel,omitempty"`
	TransferAckLevel                          *int64                       `json:"transferAckLevel,omitempty"`
	TimerAckLevelNanos                        *int64                       `json:"timerAckLevelNanos,omitempty"`
	DomainNotificationVersion                 *int64                       `json:"domainNotificationVersion,omitempty"`
	ClusterTransferAckLevel                   map[string]int64             `json:"clusterTransferAckLevel,omitempty"`
	ClusterTimerAckLevel                      map[string]int64             `json:"clusterTimerAckLevel,omitempty"`
	Owner                                     *string                      `json:"owner,omitempty"`
	ClusterReplicationLevel                   map[string]int64             `json:"clusterReplicationLevel,omitempty"`
	PendingFailoverMarkers                    []byte                       `json:"pendingFailoverMarkers,omitempty"`
	PendingFailoverMarkersEncoding            *string                      `json:"pendingFailoverMarkersEncoding,omitempty"`
	ReplicationDlqAckLevel                    map[string]int64             `json:"replicationDlqAckLevel,omitempty"`
	TransferProcessingQueueStates             []byte                       `json:"transferProcessingQueueStates,omitempty"`
	TransferProcessingQueueStatesEncoding     *string                      `json:"transferProcessingQueueStatesEncoding,omitempty"`
	TimerProcessingQueueStates                []byte                       `json:"timerProcessingQueueStates,omitempty"`
	TimerProcessingQueueStatesEncoding        *string                      `json:"timerProcessingQueueStatesEncoding,omitempty"`
	CrossClusterProcessingQueueStates         []byte                       `json:"crossClusterProcessingQueueStates,omitempty"`
	CrossClusterProcessingQueueStatesEncoding *string                      `json:"crossClusterProcessingQueueStatesEncoding,omitempty"`
	QueueStates                               map[int32]*shared.QueueState `json:"queueStates,omitempty"`
}

type _Map_String_I64_MapItemList map[string]int64

func (m _Map_String_I64_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI64(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_I64_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_I64_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_I64_MapItemList) ValueType() wire.Type {
	return wire.TI64
}

func (_Map_String_I64_MapItemList) Close() {}

type _Map_I32_QueueState_MapItemList map[int32]*shared.QueueState

func (m _Map_I32_QueueState_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid map 'map[int32]*shared.QueueState', key [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_QueueState_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_QueueState_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_QueueState_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I32_QueueState_MapItemList) Close() {}

// ToWire translates a ShardInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *ShardInfo) ToWire() (wire.Value, error) {
	var (
		fields [20]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StolenSinceRenew != nil {
		w, err = wire.NewValueI32(*(v.StolenSinceRenew)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.UpdatedAtNanos != nil {
		w, err = wire.NewValueI64(*(v.UpdatedAtNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ReplicationAckLevel != nil {
		w, err = wire.NewValueI64(*(v.ReplicationAckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.TransferAckLevel != nil {
		w, err = wire.NewValueI64(*(v.TransferAckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.TimerAckLevelNanos != nil {
		w, err = wire.NewValueI64(*(v.TimerAckLevelNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.DomainNotificationVersion != nil {
		w, err = wire.NewValueI64(*(v.DomainNotificationVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.ClusterTransferAckLevel != nil {
		w, err = wire.NewValueMap(_Map_String_I64_MapItemList(v.ClusterTransferAckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.ClusterTimerAckLevel != nil {
		w, err = wire.NewValueMap(_Map_String_I64_MapItemList(v.ClusterTimerAckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 36, Value: w}
		i++
	}
	if v.Owner != nil {
		w, err = wire.NewValueString(*(v.Owner)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}
	if v.ClusterReplicationLevel != nil {
		w, err = wire.NewValueMap(_Map_String_I64_MapItemList(v.ClusterReplicationLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.PendingFailoverMarkers != nil {
		w, err = wire.NewValueBinary(v.PendingFailoverMarkers), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 42, Value: w}
		i++
	}
	if v.PendingFailoverMarkersEncoding != nil {
		w, err = wire.NewValueString(*(v.PendingFailoverMarkersEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 44, Value: w}
		i++
	}
	if v.ReplicationDlqAckLevel != nil {
		w, err = wire.NewValueMap(_Map_String_I64_MapItemList(v.ReplicationDlqAckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 46, Value: w}
		i++
	}
	if v.TransferProcessingQueueStates != nil {
		w, err = wire.NewValueBinary(v.TransferProcessingQueueStates), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.TransferProcessingQueueStatesEncoding != nil {
		w, err = wire.NewValueString(*(v.TransferProcessingQueueStatesEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 51, Value: w}
		i++
	}
	if v.TimerProcessingQueueStates != nil {
		w, err = wire.NewValueBinary(v.TimerProcessingQueueStates), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 55, Value: w}
		i++
	}
	if v.TimerProcessingQueueStatesEncoding != nil {
		w, err = wire.NewValueString(*(v.TimerProcessingQueueStatesEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 56, Value: w}
		i++
	}
	if v.CrossClusterProcessingQueueStates != nil {
		w, err = wire.NewValueBinary(v.CrossClusterProcessingQueueStates), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.CrossClusterProcessingQueueStatesEncoding != nil {
		w, err = wire.NewValueString(*(v.CrossClusterProcessingQueueStatesEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 61, Value: w}
		i++
	}
	if v.QueueStates != nil {
		w, err = wire.NewValueMap(_Map_I32_QueueState_MapItemList(v.QueueStates)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 64, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_I64_Read(m wire.MapItemList) (map[string]int64, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI64 {
		return nil, nil
	}

	o := make(map[string]int64, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI64(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _QueueState_Read(w wire.Value) (*shared.QueueState, error) {
	var v shared.QueueState
	err := v.FromWire(w)
	return &v, err
}

func _Map_I32_QueueState_Read(m wire.MapItemList) (map[int32]*shared.QueueState, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[int32]*shared.QueueState, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _QueueState_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a ShardInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ShardInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v ShardInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *ShardInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.StolenSinceRenew = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.UpdatedAtNanos = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ReplicationAckLevel = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TransferAckLevel = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TimerAckLevelNanos = &x
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DomainNotificationVersion = &x
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TMap {
				v.ClusterTransferAckLevel, err = _Map_String_I64_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 36:
			if field.Value.Type() == wire.TMap {
				v.ClusterTimerAckLevel, err = _Map_String_I64_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Owner = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TMap {
				v.ClusterReplicationLevel, err = _Map_String_I64_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 42:
			if field.Value.Type() == wire.TBinary {
				v.PendingFailoverMarkers, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 44:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.PendingFailoverMarkersEncoding = &x
				if err != nil {
					return err
				}

			}
		case 46:
			if field.Value.Type() == wire.TMap {
				v.ReplicationDlqAckLevel, err = _Map_String_I64_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				v.TransferProcessingQueueStates, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 51:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TransferProcessingQueueStatesEncoding = &x
				if err != nil {
					return err
				}

			}
		case 55:
			if field.Value.Type() == wire.TBinary {
				v.TimerProcessingQueueStates, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 56:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TimerProcessingQueueStatesEncoding = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				v.CrossClusterProcessingQueueStates, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 61:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CrossClusterProcessingQueueStatesEncoding = &x
				if err != nil {
					return err
				}

			}
		case 64:
			if field.Value.Type() == wire.TMap {
				v.QueueStates, err = _Map_I32_QueueState_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Map_String_I64_Encode(val map[string]int64, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TI64,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := sw.WriteInt64(v); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

func _Map_I32_QueueState_Encode(val map[int32]*shared.QueueState, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TI32,
		ValueType: wire.TStruct,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if v == nil {
			return fmt.Errorf("invalid map 'map[int32]*shared.QueueState', key [%v]: value is nil", k)
		}
		if err := sw.WriteInt32(k); err != nil {
			return err
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

// Encode serializes a ShardInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ShardInfo struct could not be encoded.
func (v *ShardInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.StolenSinceRenew != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.StolenSinceRenew)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.UpdatedAtNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.UpdatedAtNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ReplicationAckLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ReplicationAckLevel)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TransferAckLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.TransferAckLevel)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TimerAckLevelNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.TimerAckLevelNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DomainNotificationVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DomainNotificationVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClusterTransferAckLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 34, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_I64_Encode(v.ClusterTransferAckLevel, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClusterTimerAckLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 36, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_I64_Encode(v.ClusterTimerAckLevel, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Owner != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 38, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Owner)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClusterReplicationLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 40, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_I64_Encode(v.ClusterReplicationLevel, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.PendingFailoverMarkers != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 42, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.PendingFailoverMarkers); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.PendingFailoverMarkersEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 44, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.PendingFailoverMarkersEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ReplicationDlqAckLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 46, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_I64_Encode(v.ReplicationDlqAckLevel, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TransferProcessingQueueStates != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 50, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.TransferProcessingQueueStates); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TransferProcessingQueueStatesEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 51, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.TransferProcessingQueueStatesEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TimerProcessingQueueStates != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 55, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.TimerProcessingQueueStates); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TimerProcessingQueueStatesEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 56, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.TimerProcessingQueueStatesEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CrossClusterProcessingQueueStates != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 60, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.CrossClusterProcessingQueueStates); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CrossClusterProcessingQueueStatesEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 61, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CrossClusterProcessingQueueStatesEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.QueueStates != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 64, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_I32_QueueState_Encode(v.QueueStates, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Map_String_I64_Decode(sr stream.Reader) (map[string]int64, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TI64 {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string]int64, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := sr.ReadInt64()
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

func _QueueState_Decode(sr stream.Reader) (*shared.QueueState, error) {
	var v shared.QueueState
	err := v.Decode(sr)
	return &v, err
}

func _Map_I32_QueueState_Decode(sr stream.Reader) (map[int32]*shared.QueueState, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TI32 || mh.ValueType != wire.TStruct {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[int32]*shared.QueueState, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadInt32()
		if err != nil {
			return nil, err
		}

		v, err := _QueueState_Decode(sr)
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a ShardInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ShardInfo struct could not be generated from the wire
// representation.
func (v *ShardInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.StolenSinceRenew = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.UpdatedAtNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ReplicationAckLevel = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.TransferAckLevel = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.TimerAckLevelNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DomainNotificationVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 34 && fh.Type == wire.TMap:
			v.ClusterTransferAckLevel, err = _Map_String_I64_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 36 && fh.Type == wire.TMap:
			v.ClusterTimerAckLevel, err = _Map_String_I64_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 38 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Owner = &x
			if err != nil {
				return err
			}

		case fh.ID == 40 && fh.Type == wire.TMap:
			v.ClusterReplicationLevel, err = _Map_String_I64_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 42 && fh.Type == wire.TBinary:
			v.PendingFailoverMarkers, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 44 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.PendingFailoverMarkersEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 46 && fh.Type == wire.TMap:
			v.ReplicationDlqAckLevel, err = _Map_String_I64_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 50 && fh.Type == wire.TBinary:
			v.TransferProcessingQueueStates, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 51 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.TransferProcessingQueueStatesEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 55 && fh.Type == wire.TBinary:
			v.TimerProcessingQueueStates, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 56 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.TimerProcessingQueueStatesEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 60 && fh.Type == wire.TBinary:
			v.CrossClusterProcessingQueueStates, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 61 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CrossClusterProcessingQueueStatesEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 64 && fh.Type == wire.TMap:
			v.QueueStates, err = _Map_I32_QueueState_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ShardInfo
// struct.
func (v *ShardInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [20]string
	i := 0
	if v.StolenSinceRenew != nil {
		fields[i] = fmt.Sprintf("StolenSinceRenew: %v", *(v.StolenSinceRenew))
		i++
	}
	if v.UpdatedAtNanos != nil {
		fields[i] = fmt.Sprintf("UpdatedAtNanos: %v", *(v.UpdatedAtNanos))
		i++
	}
	if v.ReplicationAckLevel != nil {
		fields[i] = fmt.Sprintf("ReplicationAckLevel: %v", *(v.ReplicationAckLevel))
		i++
	}
	if v.TransferAckLevel != nil {
		fields[i] = fmt.Sprintf("TransferAckLevel: %v", *(v.TransferAckLevel))
		i++
	}
	if v.TimerAckLevelNanos != nil {
		fields[i] = fmt.Sprintf("TimerAckLevelNanos: %v", *(v.TimerAckLevelNanos))
		i++
	}
	if v.DomainNotificationVersion != nil {
		fields[i] = fmt.Sprintf("DomainNotificationVersion: %v", *(v.DomainNotificationVersion))
		i++
	}
	if v.ClusterTransferAckLevel != nil {
		fields[i] = fmt.Sprintf("ClusterTransferAckLevel: %v", v.ClusterTransferAckLevel)
		i++
	}
	if v.ClusterTimerAckLevel != nil {
		fields[i] = fmt.Sprintf("ClusterTimerAckLevel: %v", v.ClusterTimerAckLevel)
		i++
	}
	if v.Owner != nil {
		fields[i] = fmt.Sprintf("Owner: %v", *(v.Owner))
		i++
	}
	if v.ClusterReplicationLevel != nil {
		fields[i] = fmt.Sprintf("ClusterReplicationLevel: %v", v.ClusterReplicationLevel)
		i++
	}
	if v.PendingFailoverMarkers != nil {
		fields[i] = fmt.Sprintf("PendingFailoverMarkers: %v", v.PendingFailoverMarkers)
		i++
	}
	if v.PendingFailoverMarkersEncoding != nil {
		fields[i] = fmt.Sprintf("PendingFailoverMarkersEncoding: %v", *(v.PendingFailoverMarkersEncoding))
		i++
	}
	if v.ReplicationDlqAckLevel != nil {
		fields[i] = fmt.Sprintf("ReplicationDlqAckLevel: %v", v.ReplicationDlqAckLevel)
		i++
	}
	if v.TransferProcessingQueueStates != nil {
		fields[i] = fmt.Sprintf("TransferProcessingQueueStates: %v", v.TransferProcessingQueueStates)
		i++
	}
	if v.TransferProcessingQueueStatesEncoding != nil {
		fields[i] = fmt.Sprintf("TransferProcessingQueueStatesEncoding: %v", *(v.TransferProcessingQueueStatesEncoding))
		i++
	}
	if v.TimerProcessingQueueStates != nil {
		fields[i] = fmt.Sprintf("TimerProcessingQueueStates: %v", v.TimerProcessingQueueStates)
		i++
	}
	if v.TimerProcessingQueueStatesEncoding != nil {
		fields[i] = fmt.Sprintf("TimerProcessingQueueStatesEncoding: %v", *(v.TimerProcessingQueueStatesEncoding))
		i++
	}
	if v.CrossClusterProcessingQueueStates != nil {
		fields[i] = fmt.Sprintf("CrossClusterProcessingQueueStates: %v", v.CrossClusterProcessingQueueStates)
		i++
	}
	if v.CrossClusterProcessingQueueStatesEncoding != nil {
		fields[i] = fmt.Sprintf("CrossClusterProcessingQueueStatesEncoding: %v", *(v.CrossClusterProcessingQueueStatesEncoding))
		i++
	}
	if v.QueueStates != nil {
		fields[i] = fmt.Sprintf("QueueStates: %v", v.QueueStates)
		i++
	}

	return fmt.Sprintf("ShardInfo{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_I64_Equals(lhs, rhs map[string]int64) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _Map_I32_QueueState_Equals(lhs, rhs map[int32]*shared.QueueState) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this ShardInfo match the
// provided ShardInfo.
//
// This function performs a deep comparison.
func (v *ShardInfo) Equals(rhs *ShardInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.StolenSinceRenew, rhs.StolenSinceRenew) {
		return false
	}
	if !_I64_EqualsPtr(v.UpdatedAtNanos, rhs.UpdatedAtNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.ReplicationAckLevel, rhs.ReplicationAckLevel) {
		return false
	}
	if !_I64_EqualsPtr(v.TransferAckLevel, rhs.TransferAckLevel) {
		return false
	}
	if !_I64_EqualsPtr(v.TimerAckLevelNanos, rhs.TimerAckLevelNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.DomainNotificationVersion, rhs.DomainNotificationVersion) {
		return false
	}
	if !((v.ClusterTransferAckLevel == nil && rhs.ClusterTransferAckLevel == nil) || (v.ClusterTransferAckLevel != nil && rhs.ClusterTransferAckLevel != nil && _Map_String_I64_Equals(v.ClusterTransferAckLevel, rhs.ClusterTransferAckLevel))) {
		return false
	}
	if !((v.ClusterTimerAckLevel == nil && rhs.ClusterTimerAckLevel == nil) || (v.ClusterTimerAckLevel != nil && rhs.ClusterTimerAckLevel != nil && _Map_String_I64_Equals(v.ClusterTimerAckLevel, rhs.ClusterTimerAckLevel))) {
		return false
	}
	if !_String_EqualsPtr(v.Owner, rhs.Owner) {
		return false
	}
	if !((v.ClusterReplicationLevel == nil && rhs.ClusterReplicationLevel == nil) || (v.ClusterReplicationLevel != nil && rhs.ClusterReplicationLevel != nil && _Map_String_I64_Equals(v.ClusterReplicationLevel, rhs.ClusterReplicationLevel))) {
		return false
	}
	if !((v.PendingFailoverMarkers == nil && rhs.PendingFailoverMarkers == nil) || (v.PendingFailoverMarkers != nil && rhs.PendingFailoverMarkers != nil && bytes.Equal(v.PendingFailoverMarkers, rhs.PendingFailoverMarkers))) {
		return false
	}
	if !_String_EqualsPtr(v.PendingFailoverMarkersEncoding, rhs.PendingFailoverMarkersEncoding) {
		return false
	}
	if !((v.ReplicationDlqAckLevel == nil && rhs.ReplicationDlqAckLevel == nil) || (v.ReplicationDlqAckLevel != nil && rhs.ReplicationDlqAckLevel != nil && _Map_String_I64_Equals(v.ReplicationDlqAckLevel, rhs.ReplicationDlqAckLevel))) {
		return false
	}
	if !((v.TransferProcessingQueueStates == nil && rhs.TransferProcessingQueueStates == nil) || (v.TransferProcessingQueueStates != nil && rhs.TransferProcessingQueueStates != nil && bytes.Equal(v.TransferProcessingQueueStates, rhs.TransferProcessingQueueStates))) {
		return false
	}
	if !_String_EqualsPtr(v.TransferProcessingQueueStatesEncoding, rhs.TransferProcessingQueueStatesEncoding) {
		return false
	}
	if !((v.TimerProcessingQueueStates == nil && rhs.TimerProcessingQueueStates == nil) || (v.TimerProcessingQueueStates != nil && rhs.TimerProcessingQueueStates != nil && bytes.Equal(v.TimerProcessingQueueStates, rhs.TimerProcessingQueueStates))) {
		return false
	}
	if !_String_EqualsPtr(v.TimerProcessingQueueStatesEncoding, rhs.TimerProcessingQueueStatesEncoding) {
		return false
	}
	if !((v.CrossClusterProcessingQueueStates == nil && rhs.CrossClusterProcessingQueueStates == nil) || (v.CrossClusterProcessingQueueStates != nil && rhs.CrossClusterProcessingQueueStates != nil && bytes.Equal(v.CrossClusterProcessingQueueStates, rhs.CrossClusterProcessingQueueStates))) {
		return false
	}
	if !_String_EqualsPtr(v.CrossClusterProcessingQueueStatesEncoding, rhs.CrossClusterProcessingQueueStatesEncoding) {
		return false
	}
	if !((v.QueueStates == nil && rhs.QueueStates == nil) || (v.QueueStates != nil && rhs.QueueStates != nil && _Map_I32_QueueState_Equals(v.QueueStates, rhs.QueueStates))) {
		return false
	}

	return true
}

type _Map_String_I64_Zapper map[string]int64

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_I64_Zapper.
func (m _Map_String_I64_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt64((string)(k), v)
	}
	return err
}

type _Map_I32_QueueState_Item_Zapper struct {
	Key   int32
	Value *shared.QueueState
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_QueueState_Item_Zapper.
func (v _Map_I32_QueueState_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_I32_QueueState_Zapper map[int32]*shared.QueueState

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_QueueState_Zapper.
func (m _Map_I32_QueueState_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_QueueState_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ShardInfo.
func (v *ShardInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StolenSinceRenew != nil {
		enc.AddInt32("stolenSinceRenew", *v.StolenSinceRenew)
	}
	if v.UpdatedAtNanos != nil {
		enc.AddInt64("updatedAtNanos", *v.UpdatedAtNanos)
	}
	if v.ReplicationAckLevel != nil {
		enc.AddInt64("replicationAckLevel", *v.ReplicationAckLevel)
	}
	if v.TransferAckLevel != nil {
		enc.AddInt64("transferAckLevel", *v.TransferAckLevel)
	}
	if v.TimerAckLevelNanos != nil {
		enc.AddInt64("timerAckLevelNanos", *v.TimerAckLevelNanos)
	}
	if v.DomainNotificationVersion != nil {
		enc.AddInt64("domainNotificationVersion", *v.DomainNotificationVersion)
	}
	if v.ClusterTransferAckLevel != nil {
		err = multierr.Append(err, enc.AddObject("clusterTransferAckLevel", (_Map_String_I64_Zapper)(v.ClusterTransferAckLevel)))
	}
	if v.ClusterTimerAckLevel != nil {
		err = multierr.Append(err, enc.AddObject("clusterTimerAckLevel", (_Map_String_I64_Zapper)(v.ClusterTimerAckLevel)))
	}
	if v.Owner != nil {
		enc.AddString("owner", *v.Owner)
	}
	if v.ClusterReplicationLevel != nil {
		err = multierr.Append(err, enc.AddObject("clusterReplicationLevel", (_Map_String_I64_Zapper)(v.ClusterReplicationLevel)))
	}
	if v.PendingFailoverMarkers != nil {
		enc.AddString("pendingFailoverMarkers", base64.StdEncoding.EncodeToString(v.PendingFailoverMarkers))
	}
	if v.PendingFailoverMarkersEncoding != nil {
		enc.AddString("pendingFailoverMarkersEncoding", *v.PendingFailoverMarkersEncoding)
	}
	if v.ReplicationDlqAckLevel != nil {
		err = multierr.Append(err, enc.AddObject("replicationDlqAckLevel", (_Map_String_I64_Zapper)(v.ReplicationDlqAckLevel)))
	}
	if v.TransferProcessingQueueStates != nil {
		enc.AddString("transferProcessingQueueStates", base64.StdEncoding.EncodeToString(v.TransferProcessingQueueStates))
	}
	if v.TransferProcessingQueueStatesEncoding != nil {
		enc.AddString("transferProcessingQueueStatesEncoding", *v.TransferProcessingQueueStatesEncoding)
	}
	if v.TimerProcessingQueueStates != nil {
		enc.AddString("timerProcessingQueueStates", base64.StdEncoding.EncodeToString(v.TimerProcessingQueueStates))
	}
	if v.TimerProcessingQueueStatesEncoding != nil {
		enc.AddString("timerProcessingQueueStatesEncoding", *v.TimerProcessingQueueStatesEncoding)
	}
	if v.CrossClusterProcessingQueueStates != nil {
		enc.AddString("crossClusterProcessingQueueStates", base64.StdEncoding.EncodeToString(v.CrossClusterProcessingQueueStates))
	}
	if v.CrossClusterProcessingQueueStatesEncoding != nil {
		enc.AddString("crossClusterProcessingQueueStatesEncoding", *v.CrossClusterProcessingQueueStatesEncoding)
	}
	if v.QueueStates != nil {
		err = multierr.Append(err, enc.AddArray("queueStates", (_Map_I32_QueueState_Zapper)(v.QueueStates)))
	}
	return err
}

// GetStolenSinceRenew returns the value of StolenSinceRenew if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetStolenSinceRenew() (o int32) {
	if v != nil && v.StolenSinceRenew != nil {
		return *v.StolenSinceRenew
	}

	return
}

// IsSetStolenSinceRenew returns true if StolenSinceRenew is not nil.
func (v *ShardInfo) IsSetStolenSinceRenew() bool {
	return v != nil && v.StolenSinceRenew != nil
}

// GetUpdatedAtNanos returns the value of UpdatedAtNanos if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetUpdatedAtNanos() (o int64) {
	if v != nil && v.UpdatedAtNanos != nil {
		return *v.UpdatedAtNanos
	}

	return
}

// IsSetUpdatedAtNanos returns true if UpdatedAtNanos is not nil.
func (v *ShardInfo) IsSetUpdatedAtNanos() bool {
	return v != nil && v.UpdatedAtNanos != nil
}

// GetReplicationAckLevel returns the value of ReplicationAckLevel if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetReplicationAckLevel() (o int64) {
	if v != nil && v.ReplicationAckLevel != nil {
		return *v.ReplicationAckLevel
	}

	return
}

// IsSetReplicationAckLevel returns true if ReplicationAckLevel is not nil.
func (v *ShardInfo) IsSetReplicationAckLevel() bool {
	return v != nil && v.ReplicationAckLevel != nil
}

// GetTransferAckLevel returns the value of TransferAckLevel if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetTransferAckLevel() (o int64) {
	if v != nil && v.TransferAckLevel != nil {
		return *v.TransferAckLevel
	}

	return
}

// IsSetTransferAckLevel returns true if TransferAckLevel is not nil.
func (v *ShardInfo) IsSetTransferAckLevel() bool {
	return v != nil && v.TransferAckLevel != nil
}

// GetTimerAckLevelNanos returns the value of TimerAckLevelNanos if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetTimerAckLevelNanos() (o int64) {
	if v != nil && v.TimerAckLevelNanos != nil {
		return *v.TimerAckLevelNanos
	}

	return
}

// IsSetTimerAckLevelNanos returns true if TimerAckLevelNanos is not nil.
func (v *ShardInfo) IsSetTimerAckLevelNanos() bool {
	return v != nil && v.TimerAckLevelNanos != nil
}

// GetDomainNotificationVersion returns the value of DomainNotificationVersion if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetDomainNotificationVersion() (o int64) {
	if v != nil && v.DomainNotificationVersion != nil {
		return *v.DomainNotificationVersion
	}

	return
}

// IsSetDomainNotificationVersion returns true if DomainNotificationVersion is not nil.
func (v *ShardInfo) IsSetDomainNotificationVersion() bool {
	return v != nil && v.DomainNotificationVersion != nil
}

// GetClusterTransferAckLevel returns the value of ClusterTransferAckLevel if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetClusterTransferAckLevel() (o map[string]int64) {
	if v != nil && v.ClusterTransferAckLevel != nil {
		return v.ClusterTransferAckLevel
	}

	return
}

// IsSetClusterTransferAckLevel returns true if ClusterTransferAckLevel is not nil.
func (v *ShardInfo) IsSetClusterTransferAckLevel() bool {
	return v != nil && v.ClusterTransferAckLevel != nil
}

// GetClusterTimerAckLevel returns the value of ClusterTimerAckLevel if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetClusterTimerAckLevel() (o map[string]int64) {
	if v != nil && v.ClusterTimerAckLevel != nil {
		return v.ClusterTimerAckLevel
	}

	return
}

// IsSetClusterTimerAckLevel returns true if ClusterTimerAckLevel is not nil.
func (v *ShardInfo) IsSetClusterTimerAckLevel() bool {
	return v != nil && v.ClusterTimerAckLevel != nil
}

// GetOwner returns the value of Owner if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetOwner() (o string) {
	if v != nil && v.Owner != nil {
		return *v.Owner
	}

	return
}

// IsSetOwner returns true if Owner is not nil.
func (v *ShardInfo) IsSetOwner() bool {
	return v != nil && v.Owner != nil
}

// GetClusterReplicationLevel returns the value of ClusterReplicationLevel if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetClusterReplicationLevel() (o map[string]int64) {
	if v != nil && v.ClusterReplicationLevel != nil {
		return v.ClusterReplicationLevel
	}

	return
}

// IsSetClusterReplicationLevel returns true if ClusterReplicationLevel is not nil.
func (v *ShardInfo) IsSetClusterReplicationLevel() bool {
	return v != nil && v.ClusterReplicationLevel != nil
}

// GetPendingFailoverMarkers returns the value of PendingFailoverMarkers if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetPendingFailoverMarkers() (o []byte) {
	if v != nil && v.PendingFailoverMarkers != nil {
		return v.PendingFailoverMarkers
	}

	return
}

// IsSetPendingFailoverMarkers returns true if PendingFailoverMarkers is not nil.
func (v *ShardInfo) IsSetPendingFailoverMarkers() bool {
	return v != nil && v.PendingFailoverMarkers != nil
}

// GetPendingFailoverMarkersEncoding returns the value of PendingFailoverMarkersEncoding if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetPendingFailoverMarkersEncoding() (o string) {
	if v != nil && v.PendingFailoverMarkersEncoding != nil {
		return *v.PendingFailoverMarkersEncoding
	}

	return
}

// IsSetPendingFailoverMarkersEncoding returns true if PendingFailoverMarkersEncoding is not nil.
func (v *ShardInfo) IsSetPendingFailoverMarkersEncoding() bool {
	return v != nil && v.PendingFailoverMarkersEncoding != nil
}

// GetReplicationDlqAckLevel returns the value of ReplicationDlqAckLevel if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetReplicationDlqAckLevel() (o map[string]int64) {
	if v != nil && v.ReplicationDlqAckLevel != nil {
		return v.ReplicationDlqAckLevel
	}

	return
}

// IsSetReplicationDlqAckLevel returns true if ReplicationDlqAckLevel is not nil.
func (v *ShardInfo) IsSetReplicationDlqAckLevel() bool {
	return v != nil && v.ReplicationDlqAckLevel != nil
}

// GetTransferProcessingQueueStates returns the value of TransferProcessingQueueStates if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetTransferProcessingQueueStates() (o []byte) {
	if v != nil && v.TransferProcessingQueueStates != nil {
		return v.TransferProcessingQueueStates
	}

	return
}

// IsSetTransferProcessingQueueStates returns true if TransferProcessingQueueStates is not nil.
func (v *ShardInfo) IsSetTransferProcessingQueueStates() bool {
	return v != nil && v.TransferProcessingQueueStates != nil
}

// GetTransferProcessingQueueStatesEncoding returns the value of TransferProcessingQueueStatesEncoding if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetTransferProcessingQueueStatesEncoding() (o string) {
	if v != nil && v.TransferProcessingQueueStatesEncoding != nil {
		return *v.TransferProcessingQueueStatesEncoding
	}

	return
}

// IsSetTransferProcessingQueueStatesEncoding returns true if TransferProcessingQueueStatesEncoding is not nil.
func (v *ShardInfo) IsSetTransferProcessingQueueStatesEncoding() bool {
	return v != nil && v.TransferProcessingQueueStatesEncoding != nil
}

// GetTimerProcessingQueueStates returns the value of TimerProcessingQueueStates if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetTimerProcessingQueueStates() (o []byte) {
	if v != nil && v.TimerProcessingQueueStates != nil {
		return v.TimerProcessingQueueStates
	}

	return
}

// IsSetTimerProcessingQueueStates returns true if TimerProcessingQueueStates is not nil.
func (v *ShardInfo) IsSetTimerProcessingQueueStates() bool {
	return v != nil && v.TimerProcessingQueueStates != nil
}

// GetTimerProcessingQueueStatesEncoding returns the value of TimerProcessingQueueStatesEncoding if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetTimerProcessingQueueStatesEncoding() (o string) {
	if v != nil && v.TimerProcessingQueueStatesEncoding != nil {
		return *v.TimerProcessingQueueStatesEncoding
	}

	return
}

// IsSetTimerProcessingQueueStatesEncoding returns true if TimerProcessingQueueStatesEncoding is not nil.
func (v *ShardInfo) IsSetTimerProcessingQueueStatesEncoding() bool {
	return v != nil && v.TimerProcessingQueueStatesEncoding != nil
}

// GetCrossClusterProcessingQueueStates returns the value of CrossClusterProcessingQueueStates if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetCrossClusterProcessingQueueStates() (o []byte) {
	if v != nil && v.CrossClusterProcessingQueueStates != nil {
		return v.CrossClusterProcessingQueueStates
	}

	return
}

// IsSetCrossClusterProcessingQueueStates returns true if CrossClusterProcessingQueueStates is not nil.
func (v *ShardInfo) IsSetCrossClusterProcessingQueueStates() bool {
	return v != nil && v.CrossClusterProcessingQueueStates != nil
}

// GetCrossClusterProcessingQueueStatesEncoding returns the value of CrossClusterProcessingQueueStatesEncoding if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetCrossClusterProcessingQueueStatesEncoding() (o string) {
	if v != nil && v.CrossClusterProcessingQueueStatesEncoding != nil {
		return *v.CrossClusterProcessingQueueStatesEncoding
	}

	return
}

// IsSetCrossClusterProcessingQueueStatesEncoding returns true if CrossClusterProcessingQueueStatesEncoding is not nil.
func (v *ShardInfo) IsSetCrossClusterProcessingQueueStatesEncoding() bool {
	return v != nil && v.CrossClusterProcessingQueueStatesEncoding != nil
}

// GetQueueStates returns the value of QueueStates if it is set or its
// zero value if it is unset.
func (v *ShardInfo) GetQueueStates() (o map[int32]*shared.QueueState) {
	if v != nil && v.QueueStates != nil {
		return v.QueueStates
	}

	return
}

// IsSetQueueStates returns true if QueueStates is not nil.
func (v *ShardInfo) IsSetQueueStates() bool {
	return v != nil && v.QueueStates != nil
}

type SignalInfo struct {
	Version               *int64  `json:"version,omitempty"`
	InitiatedEventBatchID *int64  `json:"initiatedEventBatchID,omitempty"`
	RequestID             *string `json:"requestID,omitempty"`
	Name                  *string `json:"name,omitempty"`
	Input                 []byte  `json:"input,omitempty"`
	Control               []byte  `json:"control,omitempty"`
}

// ToWire translates a SignalInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *SignalInfo) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.InitiatedEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.InitiatedEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.RequestID != nil {
		w, err = wire.NewValueString(*(v.RequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.Input != nil {
		w, err = wire.NewValueBinary(v.Input), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.Control != nil {
		w, err = wire.NewValueBinary(v.Control), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SignalInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SignalInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v SignalInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *SignalInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.InitiatedEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RequestID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				v.Input, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TBinary {
				v.Control, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a SignalInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a SignalInfo struct could not be encoded.
func (v *SignalInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.InitiatedEventBatchID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 11, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.InitiatedEventBatchID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.RequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Input != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.Input); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Control != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.Control); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a SignalInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a SignalInfo struct could not be generated from the wire
// representation.
func (v *SignalInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 11 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.InitiatedEventBatchID = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.RequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TBinary:
			v.Input, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TBinary:
			v.Control, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a SignalInfo
// struct.
func (v *SignalInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.InitiatedEventBatchID != nil {
		fields[i] = fmt.Sprintf("InitiatedEventBatchID: %v", *(v.InitiatedEventBatchID))
		i++
	}
	if v.RequestID != nil {
		fields[i] = fmt.Sprintf("RequestID: %v", *(v.RequestID))
		i++
	}
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Input != nil {
		fields[i] = fmt.Sprintf("Input: %v", v.Input)
		i++
	}
	if v.Control != nil {
		fields[i] = fmt.Sprintf("Control: %v", v.Control)
		i++
	}

	return fmt.Sprintf("SignalInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SignalInfo match the
// provided SignalInfo.
//
// This function performs a deep comparison.
func (v *SignalInfo) Equals(rhs *SignalInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.InitiatedEventBatchID, rhs.InitiatedEventBatchID) {
		return false
	}
	if !_String_EqualsPtr(v.RequestID, rhs.RequestID) {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.Input == nil && rhs.Input == nil) || (v.Input != nil && rhs.Input != nil && bytes.Equal(v.Input, rhs.Input))) {
		return false
	}
	if !((v.Control == nil && rhs.Control == nil) || (v.Control != nil && rhs.Control != nil && bytes.Equal(v.Control, rhs.Control))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SignalInfo.
func (v *SignalInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.InitiatedEventBatchID != nil {
		enc.AddInt64("initiatedEventBatchID", *v.InitiatedEventBatchID)
	}
	if v.RequestID != nil {
		enc.AddString("requestID", *v.RequestID)
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Input != nil {
		enc.AddString("input", base64.StdEncoding.EncodeToString(v.Input))
	}
	if v.Control != nil {
		enc.AddString("control", base64.StdEncoding.EncodeToString(v.Control))
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *SignalInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *SignalInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetInitiatedEventBatchID returns the value of InitiatedEventBatchID if it is set or its
// zero value if it is unset.
func (v *SignalInfo) GetInitiatedEventBatchID() (o int64) {
	if v != nil && v.InitiatedEventBatchID != nil {
		return *v.InitiatedEventBatchID
	}

	return
}

// IsSetInitiatedEventBatchID returns true if InitiatedEventBatchID is not nil.
func (v *SignalInfo) IsSetInitiatedEventBatchID() bool {
	return v != nil && v.InitiatedEventBatchID != nil
}

// GetRequestID returns the value of RequestID if it is set or its
// zero value if it is unset.
func (v *SignalInfo) GetRequestID() (o string) {
	if v != nil && v.RequestID != nil {
		return *v.RequestID
	}

	return
}

// IsSetRequestID returns true if RequestID is not nil.
func (v *SignalInfo) IsSetRequestID() bool {
	return v != nil && v.RequestID != nil
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *SignalInfo) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *SignalInfo) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetInput returns the value of Input if it is set or its
// zero value if it is unset.
func (v *SignalInfo) GetInput() (o []byte) {
	if v != nil && v.Input != nil {
		return v.Input
	}

	return
}

// IsSetInput returns true if Input is not nil.
func (v *SignalInfo) IsSetInput() bool {
	return v != nil && v.Input != nil
}

// GetControl returns the value of Control if it is set or its
// zero value if it is unset.
func (v *SignalInfo) GetControl() (o []byte) {
	if v != nil && v.Control != nil {
		return v.Control
	}

	return
}

// IsSetControl returns true if Control is not nil.
func (v *SignalInfo) IsSetControl() bool {
	return v != nil && v.Control != nil
}

type TaskInfo struct {
	WorkflowID       *string           `json:"workflowID,omitempty"`
	RunID            []byte            `json:"runID,omitempty"`
	ScheduleID       *int64            `json:"scheduleID,omitempty"`
	ExpiryTimeNanos  *int64            `json:"expiryTimeNanos,omitempty"`
	CreatedTimeNanos *int64            `json:"createdTimeNanos,omitempty"`
	PartitionConfig  map[string]string `json:"partitionConfig,omitempty"`
}

// ToWire translates a TaskInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TaskInfo) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueBinary(v.RunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ScheduleID != nil {
		w, err = wire.NewValueI64(*(v.ScheduleID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 13, Value: w}
		i++
	}
	if v.ExpiryTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.ExpiryTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.CreatedTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.CreatedTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 15, Value: w}
		i++
	}
	if v.PartitionConfig != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.PartitionConfig)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 17, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TaskInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TaskInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TaskInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				v.RunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 13:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduleID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ExpiryTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 15:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CreatedTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 17:
			if field.Value.Type() == wire.TMap {
				v.PartitionConfig, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a TaskInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TaskInfo struct could not be encoded.
func (v *TaskInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.WorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.WorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.RunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduleID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 13, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ScheduleID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ExpiryTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ExpiryTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CreatedTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 15, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.CreatedTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.PartitionConfig != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 17, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_String_Encode(v.PartitionConfig, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a TaskInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TaskInfo struct could not be generated from the wire
// representation.
func (v *TaskInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.WorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			v.RunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 13 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ScheduleID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ExpiryTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 15 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.CreatedTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 17 && fh.Type == wire.TMap:
			v.PartitionConfig, err = _Map_String_String_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TaskInfo
// struct.
func (v *TaskInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", v.RunID)
		i++
	}
	if v.ScheduleID != nil {
		fields[i] = fmt.Sprintf("ScheduleID: %v", *(v.ScheduleID))
		i++
	}
	if v.ExpiryTimeNanos != nil {
		fields[i] = fmt.Sprintf("ExpiryTimeNanos: %v", *(v.ExpiryTimeNanos))
		i++
	}
	if v.CreatedTimeNanos != nil {
		fields[i] = fmt.Sprintf("CreatedTimeNanos: %v", *(v.CreatedTimeNanos))
		i++
	}
	if v.PartitionConfig != nil {
		fields[i] = fmt.Sprintf("PartitionConfig: %v", v.PartitionConfig)
		i++
	}

	return fmt.Sprintf("TaskInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskInfo match the
// provided TaskInfo.
//
// This function performs a deep comparison.
func (v *TaskInfo) Equals(rhs *TaskInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !((v.RunID == nil && rhs.RunID == nil) || (v.RunID != nil && rhs.RunID != nil && bytes.Equal(v.RunID, rhs.RunID))) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduleID, rhs.ScheduleID) {
		return false
	}
	if !_I64_EqualsPtr(v.ExpiryTimeNanos, rhs.ExpiryTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.CreatedTimeNanos, rhs.CreatedTimeNanos) {
		return false
	}
	if !((v.PartitionConfig == nil && rhs.PartitionConfig == nil) || (v.PartitionConfig != nil && rhs.PartitionConfig != nil && _Map_String_String_Equals(v.PartitionConfig, rhs.PartitionConfig))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskInfo.
func (v *TaskInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", base64.StdEncoding.EncodeToString(v.RunID))
	}
	if v.ScheduleID != nil {
		enc.AddInt64("scheduleID", *v.ScheduleID)
	}
	if v.ExpiryTimeNanos != nil {
		enc.AddInt64("expiryTimeNanos", *v.ExpiryTimeNanos)
	}
	if v.CreatedTimeNanos != nil {
		enc.AddInt64("createdTimeNanos", *v.CreatedTimeNanos)
	}
	if v.PartitionConfig != nil {
		err = multierr.Append(err, enc.AddObject("partitionConfig", (_Map_String_String_Zapper)(v.PartitionConfig)))
	}
	return err
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *TaskInfo) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *TaskInfo) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *TaskInfo) GetRunID() (o []byte) {
	if v != nil && v.RunID != nil {
		return v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *TaskInfo) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetScheduleID returns the value of ScheduleID if it is set or its
// zero value if it is unset.
func (v *TaskInfo) GetScheduleID() (o int64) {
	if v != nil && v.ScheduleID != nil {
		return *v.ScheduleID
	}

	return
}

// IsSetScheduleID returns true if ScheduleID is not nil.
func (v *TaskInfo) IsSetScheduleID() bool {
	return v != nil && v.ScheduleID != nil
}

// GetExpiryTimeNanos returns the value of ExpiryTimeNanos if it is set or its
// zero value if it is unset.
func (v *TaskInfo) GetExpiryTimeNanos() (o int64) {
	if v != nil && v.ExpiryTimeNanos != nil {
		return *v.ExpiryTimeNanos
	}

	return
}

// IsSetExpiryTimeNanos returns true if ExpiryTimeNanos is not nil.
func (v *TaskInfo) IsSetExpiryTimeNanos() bool {
	return v != nil && v.ExpiryTimeNanos != nil
}

// GetCreatedTimeNanos returns the value of CreatedTimeNanos if it is set or its
// zero value if it is unset.
func (v *TaskInfo) GetCreatedTimeNanos() (o int64) {
	if v != nil && v.CreatedTimeNanos != nil {
		return *v.CreatedTimeNanos
	}

	return
}

// IsSetCreatedTimeNanos returns true if CreatedTimeNanos is not nil.
func (v *TaskInfo) IsSetCreatedTimeNanos() bool {
	return v != nil && v.CreatedTimeNanos != nil
}

// GetPartitionConfig returns the value of PartitionConfig if it is set or its
// zero value if it is unset.
func (v *TaskInfo) GetPartitionConfig() (o map[string]string) {
	if v != nil && v.PartitionConfig != nil {
		return v.PartitionConfig
	}

	return
}

// IsSetPartitionConfig returns true if PartitionConfig is not nil.
func (v *TaskInfo) IsSetPartitionConfig() bool {
	return v != nil && v.PartitionConfig != nil
}

type TaskListInfo struct {
	Kind                    *int16                   `json:"kind,omitempty"`
	AckLevel                *int64                   `json:"ackLevel,omitempty"`
	ExpiryTimeNanos         *int64                   `json:"expiryTimeNanos,omitempty"`
	LastUpdatedNanos        *int64                   `json:"lastUpdatedNanos,omitempty"`
	AdaptivePartitionConfig *TaskListPartitionConfig `json:"adaptivePartitionConfig,omitempty"`
}

// ToWire translates a TaskListInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TaskListInfo) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Kind != nil {
		w, err = wire.NewValueI16(*(v.Kind)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.AckLevel != nil {
		w, err = wire.NewValueI64(*(v.AckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ExpiryTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.ExpiryTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.LastUpdatedNanos != nil {
		w, err = wire.NewValueI64(*(v.LastUpdatedNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.AdaptivePartitionConfig != nil {
		w, err = v.AdaptivePartitionConfig.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskListPartitionConfig_Read(w wire.Value) (*TaskListPartitionConfig, error) {
	var v TaskListPartitionConfig
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a TaskListInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskListInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TaskListInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TaskListInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Kind = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.AckLevel = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ExpiryTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastUpdatedNanos = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TStruct {
				v.AdaptivePartitionConfig, err = _TaskListPartitionConfig_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a TaskListInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TaskListInfo struct could not be encoded.
func (v *TaskListInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Kind != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.Kind)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.AckLevel != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.AckLevel)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ExpiryTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ExpiryTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastUpdatedNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastUpdatedNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.AdaptivePartitionConfig != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.AdaptivePartitionConfig.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _TaskListPartitionConfig_Decode(sr stream.Reader) (*TaskListPartitionConfig, error) {
	var v TaskListPartitionConfig
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a TaskListInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TaskListInfo struct could not be generated from the wire
// representation.
func (v *TaskListInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.Kind = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.AckLevel = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ExpiryTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastUpdatedNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TStruct:
			v.AdaptivePartitionConfig, err = _TaskListPartitionConfig_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TaskListInfo
// struct.
func (v *TaskListInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Kind != nil {
		fields[i] = fmt.Sprintf("Kind: %v", *(v.Kind))
		i++
	}
	if v.AckLevel != nil {
		fields[i] = fmt.Sprintf("AckLevel: %v", *(v.AckLevel))
		i++
	}
	if v.ExpiryTimeNanos != nil {
		fields[i] = fmt.Sprintf("ExpiryTimeNanos: %v", *(v.ExpiryTimeNanos))
		i++
	}
	if v.LastUpdatedNanos != nil {
		fields[i] = fmt.Sprintf("LastUpdatedNanos: %v", *(v.LastUpdatedNanos))
		i++
	}
	if v.AdaptivePartitionConfig != nil {
		fields[i] = fmt.Sprintf("AdaptivePartitionConfig: %v", v.AdaptivePartitionConfig)
		i++
	}

	return fmt.Sprintf("TaskListInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskListInfo match the
// provided TaskListInfo.
//
// This function performs a deep comparison.
func (v *TaskListInfo) Equals(rhs *TaskListInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I16_EqualsPtr(v.Kind, rhs.Kind) {
		return false
	}
	if !_I64_EqualsPtr(v.AckLevel, rhs.AckLevel) {
		return false
	}
	if !_I64_EqualsPtr(v.ExpiryTimeNanos, rhs.ExpiryTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.LastUpdatedNanos, rhs.LastUpdatedNanos) {
		return false
	}
	if !((v.AdaptivePartitionConfig == nil && rhs.AdaptivePartitionConfig == nil) || (v.AdaptivePartitionConfig != nil && rhs.AdaptivePartitionConfig != nil && v.AdaptivePartitionConfig.Equals(rhs.AdaptivePartitionConfig))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListInfo.
func (v *TaskListInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Kind != nil {
		enc.AddInt16("kind", *v.Kind)
	}
	if v.AckLevel != nil {
		enc.AddInt64("ackLevel", *v.AckLevel)
	}
	if v.ExpiryTimeNanos != nil {
		enc.AddInt64("expiryTimeNanos", *v.ExpiryTimeNanos)
	}
	if v.LastUpdatedNanos != nil {
		enc.AddInt64("lastUpdatedNanos", *v.LastUpdatedNanos)
	}
	if v.AdaptivePartitionConfig != nil {
		err = multierr.Append(err, enc.AddObject("adaptivePartitionConfig", v.AdaptivePartitionConfig))
	}
	return err
}

// GetKind returns the value of Kind if it is set or its
// zero value if it is unset.
func (v *TaskListInfo) GetKind() (o int16) {
	if v != nil && v.Kind != nil {
		return *v.Kind
	}

	return
}

// IsSetKind returns true if Kind is not nil.
func (v *TaskListInfo) IsSetKind() bool {
	return v != nil && v.Kind != nil
}

// GetAckLevel returns the value of AckLevel if it is set or its
// zero value if it is unset.
func (v *TaskListInfo) GetAckLevel() (o int64) {
	if v != nil && v.AckLevel != nil {
		return *v.AckLevel
	}

	return
}

// IsSetAckLevel returns true if AckLevel is not nil.
func (v *TaskListInfo) IsSetAckLevel() bool {
	return v != nil && v.AckLevel != nil
}

// GetExpiryTimeNanos returns the value of ExpiryTimeNanos if it is set or its
// zero value if it is unset.
func (v *TaskListInfo) GetExpiryTimeNanos() (o int64) {
	if v != nil && v.ExpiryTimeNanos != nil {
		return *v.ExpiryTimeNanos
	}

	return
}

// IsSetExpiryTimeNanos returns true if ExpiryTimeNanos is not nil.
func (v *TaskListInfo) IsSetExpiryTimeNanos() bool {
	return v != nil && v.ExpiryTimeNanos != nil
}

// GetLastUpdatedNanos returns the value of LastUpdatedNanos if it is set or its
// zero value if it is unset.
func (v *TaskListInfo) GetLastUpdatedNanos() (o int64) {
	if v != nil && v.LastUpdatedNanos != nil {
		return *v.LastUpdatedNanos
	}

	return
}

// IsSetLastUpdatedNanos returns true if LastUpdatedNanos is not nil.
func (v *TaskListInfo) IsSetLastUpdatedNanos() bool {
	return v != nil && v.LastUpdatedNanos != nil
}

// GetAdaptivePartitionConfig returns the value of AdaptivePartitionConfig if it is set or its
// zero value if it is unset.
func (v *TaskListInfo) GetAdaptivePartitionConfig() (o *TaskListPartitionConfig) {
	if v != nil && v.AdaptivePartitionConfig != nil {
		return v.AdaptivePartitionConfig
	}

	return
}

// IsSetAdaptivePartitionConfig returns true if AdaptivePartitionConfig is not nil.
func (v *TaskListInfo) IsSetAdaptivePartitionConfig() bool {
	return v != nil && v.AdaptivePartitionConfig != nil
}

type TaskListPartition struct {
	IsolationGroups []string `json:"isolationGroups,omitempty"`
}

// ToWire translates a TaskListPartition struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TaskListPartition) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.IsolationGroups != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.IsolationGroups)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TaskListPartition struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskListPartition struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TaskListPartition
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TaskListPartition) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TList {
				v.IsolationGroups, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a TaskListPartition struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TaskListPartition struct could not be encoded.
func (v *TaskListPartition) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.IsolationGroups != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.IsolationGroups, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a TaskListPartition struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TaskListPartition struct could not be generated from the wire
// representation.
func (v *TaskListPartition) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TList:
			v.IsolationGroups, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TaskListPartition
// struct.
func (v *TaskListPartition) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.IsolationGroups != nil {
		fields[i] = fmt.Sprintf("IsolationGroups: %v", v.IsolationGroups)
		i++
	}

	return fmt.Sprintf("TaskListPartition{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskListPartition match the
// provided TaskListPartition.
//
// This function performs a deep comparison.
func (v *TaskListPartition) Equals(rhs *TaskListPartition) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.IsolationGroups == nil && rhs.IsolationGroups == nil) || (v.IsolationGroups != nil && rhs.IsolationGroups != nil && _List_String_Equals(v.IsolationGroups, rhs.IsolationGroups))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListPartition.
func (v *TaskListPartition) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.IsolationGroups != nil {
		err = multierr.Append(err, enc.AddArray("isolationGroups", (_List_String_Zapper)(v.IsolationGroups)))
	}
	return err
}

// GetIsolationGroups returns the value of IsolationGroups if it is set or its
// zero value if it is unset.
func (v *TaskListPartition) GetIsolationGroups() (o []string) {
	if v != nil && v.IsolationGroups != nil {
		return v.IsolationGroups
	}

	return
}

// IsSetIsolationGroups returns true if IsolationGroups is not nil.
func (v *TaskListPartition) IsSetIsolationGroups() bool {
	return v != nil && v.IsolationGroups != nil
}

type TaskListPartitionConfig struct {
	Version            *int64                       `json:"version,omitempty"`
	NumReadPartitions  *int32                       `json:"numReadPartitions,omitempty"`
	NumWritePartitions *int32                       `json:"numWritePartitions,omitempty"`
	ReadPartitions     map[int32]*TaskListPartition `json:"readPartitions,omitempty"`
	WritePartitions    map[int32]*TaskListPartition `json:"writePartitions,omitempty"`
}

type _Map_I32_TaskListPartition_MapItemList map[int32]*TaskListPartition

func (m _Map_I32_TaskListPartition_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid map 'map[int32]*TaskListPartition', key [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_TaskListPartition_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_TaskListPartition_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_TaskListPartition_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I32_TaskListPartition_MapItemList) Close() {}

// ToWire translates a TaskListPartitionConfig struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TaskListPartitionConfig) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.NumReadPartitions != nil {
		w, err = wire.NewValueI32(*(v.NumReadPartitions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.NumWritePartitions != nil {
		w, err = wire.NewValueI32(*(v.NumWritePartitions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.ReadPartitions != nil {
		w, err = wire.NewValueMap(_Map_I32_TaskListPartition_MapItemList(v.ReadPartitions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.WritePartitions != nil {
		w, err = wire.NewValueMap(_Map_I32_TaskListPartition_MapItemList(v.WritePartitions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskListPartition_Read(w wire.Value) (*TaskListPartition, error) {
	var v TaskListPartition
	err := v.FromWire(w)
	return &v, err
}

func _Map_I32_TaskListPartition_Read(m wire.MapItemList) (map[int32]*TaskListPartition, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[int32]*TaskListPartition, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _TaskListPartition_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a TaskListPartitionConfig struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskListPartitionConfig struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TaskListPartitionConfig
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TaskListPartitionConfig) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.NumReadPartitions = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.NumWritePartitions = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TMap {
				v.ReadPartitions, err = _Map_I32_TaskListPartition_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TMap {
				v.WritePartitions, err = _Map_I32_TaskListPartition_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Map_I32_TaskListPartition_Encode(val map[int32]*TaskListPartition, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TI32,
		ValueType: wire.TStruct,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if v == nil {
			return fmt.Errorf("invalid map 'map[int32]*TaskListPartition', key [%v]: value is nil", k)
		}
		if err := sw.WriteInt32(k); err != nil {
			return err
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

// Encode serializes a TaskListPartitionConfig struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TaskListPartitionConfig struct could not be encoded.
func (v *TaskListPartitionConfig) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NumReadPartitions != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.NumReadPartitions)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NumWritePartitions != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.NumWritePartitions)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ReadPartitions != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_I32_TaskListPartition_Encode(v.ReadPartitions, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WritePartitions != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_I32_TaskListPartition_Encode(v.WritePartitions, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _TaskListPartition_Decode(sr stream.Reader) (*TaskListPartition, error) {
	var v TaskListPartition
	err := v.Decode(sr)
	return &v, err
}

func _Map_I32_TaskListPartition_Decode(sr stream.Reader) (map[int32]*TaskListPartition, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TI32 || mh.ValueType != wire.TStruct {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[int32]*TaskListPartition, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadInt32()
		if err != nil {
			return nil, err
		}

		v, err := _TaskListPartition_Decode(sr)
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a TaskListPartitionConfig struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TaskListPartitionConfig struct could not be generated from the wire
// representation.
func (v *TaskListPartitionConfig) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.NumReadPartitions = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.NumWritePartitions = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TMap:
			v.ReadPartitions, err = _Map_I32_TaskListPartition_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TMap:
			v.WritePartitions, err = _Map_I32_TaskListPartition_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TaskListPartitionConfig
// struct.
func (v *TaskListPartitionConfig) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.NumReadPartitions != nil {
		fields[i] = fmt.Sprintf("NumReadPartitions: %v", *(v.NumReadPartitions))
		i++
	}
	if v.NumWritePartitions != nil {
		fields[i] = fmt.Sprintf("NumWritePartitions: %v", *(v.NumWritePartitions))
		i++
	}
	if v.ReadPartitions != nil {
		fields[i] = fmt.Sprintf("ReadPartitions: %v", v.ReadPartitions)
		i++
	}
	if v.WritePartitions != nil {
		fields[i] = fmt.Sprintf("WritePartitions: %v", v.WritePartitions)
		i++
	}

	return fmt.Sprintf("TaskListPartitionConfig{%v}", strings.Join(fields[:i], ", "))
}

func _Map_I32_TaskListPartition_Equals(lhs, rhs map[int32]*TaskListPartition) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this TaskListPartitionConfig match the
// provided TaskListPartitionConfig.
//
// This function performs a deep comparison.
func (v *TaskListPartitionConfig) Equals(rhs *TaskListPartitionConfig) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I32_EqualsPtr(v.NumReadPartitions, rhs.NumReadPartitions) {
		return false
	}
	if !_I32_EqualsPtr(v.NumWritePartitions, rhs.NumWritePartitions) {
		return false
	}
	if !((v.ReadPartitions == nil && rhs.ReadPartitions == nil) || (v.ReadPartitions != nil && rhs.ReadPartitions != nil && _Map_I32_TaskListPartition_Equals(v.ReadPartitions, rhs.ReadPartitions))) {
		return false
	}
	if !((v.WritePartitions == nil && rhs.WritePartitions == nil) || (v.WritePartitions != nil && rhs.WritePartitions != nil && _Map_I32_TaskListPartition_Equals(v.WritePartitions, rhs.WritePartitions))) {
		return false
	}

	return true
}

type _Map_I32_TaskListPartition_Item_Zapper struct {
	Key   int32
	Value *TaskListPartition
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_TaskListPartition_Item_Zapper.
func (v _Map_I32_TaskListPartition_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_I32_TaskListPartition_Zapper map[int32]*TaskListPartition

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_TaskListPartition_Zapper.
func (m _Map_I32_TaskListPartition_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_TaskListPartition_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListPartitionConfig.
func (v *TaskListPartitionConfig) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.NumReadPartitions != nil {
		enc.AddInt32("numReadPartitions", *v.NumReadPartitions)
	}
	if v.NumWritePartitions != nil {
		enc.AddInt32("numWritePartitions", *v.NumWritePartitions)
	}
	if v.ReadPartitions != nil {
		err = multierr.Append(err, enc.AddArray("readPartitions", (_Map_I32_TaskListPartition_Zapper)(v.ReadPartitions)))
	}
	if v.WritePartitions != nil {
		err = multierr.Append(err, enc.AddArray("writePartitions", (_Map_I32_TaskListPartition_Zapper)(v.WritePartitions)))
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionConfig) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *TaskListPartitionConfig) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetNumReadPartitions returns the value of NumReadPartitions if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionConfig) GetNumReadPartitions() (o int32) {
	if v != nil && v.NumReadPartitions != nil {
		return *v.NumReadPartitions
	}

	return
}

// IsSetNumReadPartitions returns true if NumReadPartitions is not nil.
func (v *TaskListPartitionConfig) IsSetNumReadPartitions() bool {
	return v != nil && v.NumReadPartitions != nil
}

// GetNumWritePartitions returns the value of NumWritePartitions if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionConfig) GetNumWritePartitions() (o int32) {
	if v != nil && v.NumWritePartitions != nil {
		return *v.NumWritePartitions
	}

	return
}

// IsSetNumWritePartitions returns true if NumWritePartitions is not nil.
func (v *TaskListPartitionConfig) IsSetNumWritePartitions() bool {
	return v != nil && v.NumWritePartitions != nil
}

// GetReadPartitions returns the value of ReadPartitions if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionConfig) GetReadPartitions() (o map[int32]*TaskListPartition) {
	if v != nil && v.ReadPartitions != nil {
		return v.ReadPartitions
	}

	return
}

// IsSetReadPartitions returns true if ReadPartitions is not nil.
func (v *TaskListPartitionConfig) IsSetReadPartitions() bool {
	return v != nil && v.ReadPartitions != nil
}

// GetWritePartitions returns the value of WritePartitions if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionConfig) GetWritePartitions() (o map[int32]*TaskListPartition) {
	if v != nil && v.WritePartitions != nil {
		return v.WritePartitions
	}

	return
}

// IsSetWritePartitions returns true if WritePartitions is not nil.
func (v *TaskListPartitionConfig) IsSetWritePartitions() bool {
	return v != nil && v.WritePartitions != nil
}

type TimerInfo struct {
	Version         *int64 `json:"version,omitempty"`
	StartedID       *int64 `json:"startedID,omitempty"`
	ExpiryTimeNanos *int64 `json:"expiryTimeNanos,omitempty"`
	TaskID          *int64 `json:"taskID,omitempty"`
}

// ToWire translates a TimerInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TimerInfo) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.StartedID != nil {
		w, err = wire.NewValueI64(*(v.StartedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ExpiryTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.ExpiryTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.TaskID != nil {
		w, err = wire.NewValueI64(*(v.TaskID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TimerInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TimerInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TimerInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TimerInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ExpiryTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TaskID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a TimerInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TimerInfo struct could not be encoded.
func (v *TimerInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartedID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StartedID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ExpiryTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ExpiryTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.TaskID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a TimerInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TimerInfo struct could not be generated from the wire
// representation.
func (v *TimerInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StartedID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ExpiryTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.TaskID = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TimerInfo
// struct.
func (v *TimerInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.StartedID != nil {
		fields[i] = fmt.Sprintf("StartedID: %v", *(v.StartedID))
		i++
	}
	if v.ExpiryTimeNanos != nil {
		fields[i] = fmt.Sprintf("ExpiryTimeNanos: %v", *(v.ExpiryTimeNanos))
		i++
	}
	if v.TaskID != nil {
		fields[i] = fmt.Sprintf("TaskID: %v", *(v.TaskID))
		i++
	}

	return fmt.Sprintf("TimerInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TimerInfo match the
// provided TimerInfo.
//
// This function performs a deep comparison.
func (v *TimerInfo) Equals(rhs *TimerInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedID, rhs.StartedID) {
		return false
	}
	if !_I64_EqualsPtr(v.ExpiryTimeNanos, rhs.ExpiryTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.TaskID, rhs.TaskID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TimerInfo.
func (v *TimerInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.StartedID != nil {
		enc.AddInt64("startedID", *v.StartedID)
	}
	if v.ExpiryTimeNanos != nil {
		enc.AddInt64("expiryTimeNanos", *v.ExpiryTimeNanos)
	}
	if v.TaskID != nil {
		enc.AddInt64("taskID", *v.TaskID)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *TimerInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *TimerInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetStartedID returns the value of StartedID if it is set or its
// zero value if it is unset.
func (v *TimerInfo) GetStartedID() (o int64) {
	if v != nil && v.StartedID != nil {
		return *v.StartedID
	}

	return
}

// IsSetStartedID returns true if StartedID is not nil.
func (v *TimerInfo) IsSetStartedID() bool {
	return v != nil && v.StartedID != nil
}

// GetExpiryTimeNanos returns the value of ExpiryTimeNanos if it is set or its
// zero value if it is unset.
func (v *TimerInfo) GetExpiryTimeNanos() (o int64) {
	if v != nil && v.ExpiryTimeNanos != nil {
		return *v.ExpiryTimeNanos
	}

	return
}

// IsSetExpiryTimeNanos returns true if ExpiryTimeNanos is not nil.
func (v *TimerInfo) IsSetExpiryTimeNanos() bool {
	return v != nil && v.ExpiryTimeNanos != nil
}

// GetTaskID returns the value of TaskID if it is set or its
// zero value if it is unset.
func (v *TimerInfo) GetTaskID() (o int64) {
	if v != nil && v.TaskID != nil {
		return *v.TaskID
	}

	return
}

// IsSetTaskID returns true if TaskID is not nil.
func (v *TimerInfo) IsSetTaskID() bool {
	return v != nil && v.TaskID != nil
}

type TimerTaskInfo struct {
	DomainID        []byte  `json:"domainID,omitempty"`
	WorkflowID      *string `json:"workflowID,omitempty"`
	RunID           []byte  `json:"runID,omitempty"`
	TaskType        *int16  `json:"taskType,omitempty"`
	TimeoutType     *int16  `json:"timeoutType,omitempty"`
	Version         *int64  `json:"version,omitempty"`
	ScheduleAttempt *int64  `json:"scheduleAttempt,omitempty"`
	EventID         *int64  `json:"eventID,omitempty"`
}

// ToWire translates a TimerTaskInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TimerTaskInfo) ToWire() (wire.Value, error) {
	var (
		fields [8]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.DomainID != nil {
		w, err = wire.NewValueBinary(v.DomainID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueBinary(v.RunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.TaskType != nil {
		w, err = wire.NewValueI16(*(v.TaskType)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.TimeoutType != nil {
		w, err = wire.NewValueI16(*(v.TimeoutType)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.ScheduleAttempt != nil {
		w, err = wire.NewValueI64(*(v.ScheduleAttempt)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.EventID != nil {
		w, err = wire.NewValueI64(*(v.EventID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TimerTaskInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TimerTaskInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TimerTaskInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TimerTaskInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.DomainID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				v.RunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.TaskType = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.TimeoutType = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduleAttempt = &x
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.EventID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a TimerTaskInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TimerTaskInfo struct could not be encoded.
func (v *TimerTaskInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.DomainID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.DomainID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.WorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.RunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskType != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.TaskType)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TimeoutType != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.TimeoutType)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduleAttempt != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ScheduleAttempt)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EventID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.EventID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a TimerTaskInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TimerTaskInfo struct could not be generated from the wire
// representation.
func (v *TimerTaskInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			v.DomainID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.WorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			v.RunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.TaskType = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.TimeoutType = &x
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ScheduleAttempt = &x
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.EventID = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TimerTaskInfo
// struct.
func (v *TimerTaskInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [8]string
	i := 0
	if v.DomainID != nil {
		fields[i] = fmt.Sprintf("DomainID: %v", v.DomainID)
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", v.RunID)
		i++
	}
	if v.TaskType != nil {
		fields[i] = fmt.Sprintf("TaskType: %v", *(v.TaskType))
		i++
	}
	if v.TimeoutType != nil {
		fields[i] = fmt.Sprintf("TimeoutType: %v", *(v.TimeoutType))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.ScheduleAttempt != nil {
		fields[i] = fmt.Sprintf("ScheduleAttempt: %v", *(v.ScheduleAttempt))
		i++
	}
	if v.EventID != nil {
		fields[i] = fmt.Sprintf("EventID: %v", *(v.EventID))
		i++
	}

	return fmt.Sprintf("TimerTaskInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TimerTaskInfo match the
// provided TimerTaskInfo.
//
// This function performs a deep comparison.
func (v *TimerTaskInfo) Equals(rhs *TimerTaskInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.DomainID == nil && rhs.DomainID == nil) || (v.DomainID != nil && rhs.DomainID != nil && bytes.Equal(v.DomainID, rhs.DomainID))) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !((v.RunID == nil && rhs.RunID == nil) || (v.RunID != nil && rhs.RunID != nil && bytes.Equal(v.RunID, rhs.RunID))) {
		return false
	}
	if !_I16_EqualsPtr(v.TaskType, rhs.TaskType) {
		return false
	}
	if !_I16_EqualsPtr(v.TimeoutType, rhs.TimeoutType) {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduleAttempt, rhs.ScheduleAttempt) {
		return false
	}
	if !_I64_EqualsPtr(v.EventID, rhs.EventID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TimerTaskInfo.
func (v *TimerTaskInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.DomainID != nil {
		enc.AddString("domainID", base64.StdEncoding.EncodeToString(v.DomainID))
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", base64.StdEncoding.EncodeToString(v.RunID))
	}
	if v.TaskType != nil {
		enc.AddInt16("taskType", *v.TaskType)
	}
	if v.TimeoutType != nil {
		enc.AddInt16("timeoutType", *v.TimeoutType)
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.ScheduleAttempt != nil {
		enc.AddInt64("scheduleAttempt", *v.ScheduleAttempt)
	}
	if v.EventID != nil {
		enc.AddInt64("eventID", *v.EventID)
	}
	return err
}

// GetDomainID returns the value of DomainID if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetDomainID() (o []byte) {
	if v != nil && v.DomainID != nil {
		return v.DomainID
	}

	return
}

// IsSetDomainID returns true if DomainID is not nil.
func (v *TimerTaskInfo) IsSetDomainID() bool {
	return v != nil && v.DomainID != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *TimerTaskInfo) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetRunID() (o []byte) {
	if v != nil && v.RunID != nil {
		return v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *TimerTaskInfo) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetTaskType returns the value of TaskType if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetTaskType() (o int16) {
	if v != nil && v.TaskType != nil {
		return *v.TaskType
	}

	return
}

// IsSetTaskType returns true if TaskType is not nil.
func (v *TimerTaskInfo) IsSetTaskType() bool {
	return v != nil && v.TaskType != nil
}

// GetTimeoutType returns the value of TimeoutType if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetTimeoutType() (o int16) {
	if v != nil && v.TimeoutType != nil {
		return *v.TimeoutType
	}

	return
}

// IsSetTimeoutType returns true if TimeoutType is not nil.
func (v *TimerTaskInfo) IsSetTimeoutType() bool {
	return v != nil && v.TimeoutType != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *TimerTaskInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetScheduleAttempt returns the value of ScheduleAttempt if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetScheduleAttempt() (o int64) {
	if v != nil && v.ScheduleAttempt != nil {
		return *v.ScheduleAttempt
	}

	return
}

// IsSetScheduleAttempt returns true if ScheduleAttempt is not nil.
func (v *TimerTaskInfo) IsSetScheduleAttempt() bool {
	return v != nil && v.ScheduleAttempt != nil
}

// GetEventID returns the value of EventID if it is set or its
// zero value if it is unset.
func (v *TimerTaskInfo) GetEventID() (o int64) {
	if v != nil && v.EventID != nil {
		return *v.EventID
	}

	return
}

// IsSetEventID returns true if EventID is not nil.
func (v *TimerTaskInfo) IsSetEventID() bool {
	return v != nil && v.EventID != nil
}

type TransferTaskInfo struct {
	DomainID                 []byte   `json:"domainID,omitempty"`
	WorkflowID               *string  `json:"workflowID,omitempty"`
	RunID                    []byte   `json:"runID,omitempty"`
	TaskType                 *int16   `json:"taskType,omitempty"`
	TargetDomainID           []byte   `json:"targetDomainID,omitempty"`
	TargetWorkflowID         *string  `json:"targetWorkflowID,omitempty"`
	TargetRunID              []byte   `json:"targetRunID,omitempty"`
	TaskList                 *string  `json:"taskList,omitempty"`
	TargetChildWorkflowOnly  *bool    `json:"targetChildWorkflowOnly,omitempty"`
	ScheduleID               *int64   `json:"scheduleID,omitempty"`
	Version                  *int64   `json:"version,omitempty"`
	VisibilityTimestampNanos *int64   `json:"visibilityTimestampNanos,omitempty"`
	TargetDomainIDs          [][]byte `json:"targetDomainIDs,omitempty"`
}

type _Set_Binary_sliceType_ValueList [][]byte

func (v _Set_Binary_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set '[]byte': contains nil value")
		}
		w, err := wire.NewValueBinary(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Binary_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Binary_sliceType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_Binary_sliceType_ValueList) Close() {}

// ToWire translates a TransferTaskInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *TransferTaskInfo) ToWire() (wire.Value, error) {
	var (
		fields [13]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.DomainID != nil {
		w, err = wire.NewValueBinary(v.DomainID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueBinary(v.RunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.TaskType != nil {
		w, err = wire.NewValueI16(*(v.TaskType)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.TargetDomainID != nil {
		w, err = wire.NewValueBinary(v.TargetDomainID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.TargetWorkflowID != nil {
		w, err = wire.NewValueString(*(v.TargetWorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.TargetRunID != nil {
		w, err = wire.NewValueBinary(v.TargetRunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = wire.NewValueString(*(v.TaskList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.TargetChildWorkflowOnly != nil {
		w, err = wire.NewValueBool(*(v.TargetChildWorkflowOnly)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.ScheduleID != nil {
		w, err = wire.NewValueI64(*(v.ScheduleID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.VisibilityTimestampNanos != nil {
		w, err = wire.NewValueI64(*(v.VisibilityTimestampNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.TargetDomainIDs != nil {
		w, err = wire.NewValueSet(_Set_Binary_sliceType_ValueList(v.TargetDomainIDs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_Binary_sliceType_Read(s wire.ValueList) ([][]byte, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([][]byte, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetBinary(), error(nil)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a TransferTaskInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TransferTaskInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v TransferTaskInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *TransferTaskInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.DomainID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				v.RunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.TaskType = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TBinary {
				v.TargetDomainID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TargetWorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				v.TargetRunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TaskList = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.TargetChildWorkflowOnly = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduleID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.VisibilityTimestampNanos = &x
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TSet {
				v.TargetDomainIDs, err = _Set_Binary_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Set_Binary_sliceType_Encode(val [][]byte, sw stream.Writer) error {

	sh := stream.SetHeader{
		Type:   wire.TBinary,
		Length: len(val),
	}

	if err := sw.WriteSetBegin(sh); err != nil {
		return err
	}

	for _, v := range val {
		if v == nil {
			return fmt.Errorf("invalid set '[]byte': contains nil value")
		}

		if err := sw.WriteBinary(v); err != nil {
			return err
		}
	}
	return sw.WriteSetEnd()
}

// Encode serializes a TransferTaskInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TransferTaskInfo struct could not be encoded.
func (v *TransferTaskInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.DomainID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.DomainID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.WorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.RunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskType != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI16}); err != nil {
			return err
		}
		if err := sw.WriteInt16(*(v.TaskType)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TargetDomainID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.TargetDomainID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TargetWorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.TargetWorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TargetRunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.TargetRunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskList != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.TaskList)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TargetChildWorkflowOnly != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 26, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.TargetChildWorkflowOnly)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ScheduleID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 28, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.ScheduleID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 30, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.VisibilityTimestampNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 32, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.VisibilityTimestampNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TargetDomainIDs != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 34, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_Binary_sliceType_Encode(v.TargetDomainIDs, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Set_Binary_sliceType_Decode(sr stream.Reader) ([][]byte, error) {
	sh, err := sr.ReadSetBegin()
	if err != nil {
		return nil, err
	}

	if sh.Type != wire.TBinary {
		for i := 0; i < sh.Length; i++ {
			if err := sr.Skip(sh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadSetEnd()
	}

	o := make([][]byte, 0, sh.Length)
	for i := 0; i < sh.Length; i++ {
		v, err := sr.ReadBinary()
		if err != nil {
			return nil, err
		}

		o = append(o, v)
	}

	if err = sr.ReadSetEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a TransferTaskInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TransferTaskInfo struct could not be generated from the wire
// representation.
func (v *TransferTaskInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			v.DomainID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.WorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			v.RunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI16:
			var x int16
			x, err = sr.ReadInt16()
			v.TaskType = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TBinary:
			v.TargetDomainID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.TargetWorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TBinary:
			v.TargetRunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.TaskList = &x
			if err != nil {
				return err
			}

		case fh.ID == 26 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.TargetChildWorkflowOnly = &x
			if err != nil {
				return err
			}

		case fh.ID == 28 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.ScheduleID = &x
			if err != nil {
				return err
			}

		case fh.ID == 30 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 32 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.VisibilityTimestampNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 34 && fh.Type == wire.TSet:
			v.TargetDomainIDs, err = _Set_Binary_sliceType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TransferTaskInfo
// struct.
func (v *TransferTaskInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [13]string
	i := 0
	if v.DomainID != nil {
		fields[i] = fmt.Sprintf("DomainID: %v", v.DomainID)
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", v.RunID)
		i++
	}
	if v.TaskType != nil {
		fields[i] = fmt.Sprintf("TaskType: %v", *(v.TaskType))
		i++
	}
	if v.TargetDomainID != nil {
		fields[i] = fmt.Sprintf("TargetDomainID: %v", v.TargetDomainID)
		i++
	}
	if v.TargetWorkflowID != nil {
		fields[i] = fmt.Sprintf("TargetWorkflowID: %v", *(v.TargetWorkflowID))
		i++
	}
	if v.TargetRunID != nil {
		fields[i] = fmt.Sprintf("TargetRunID: %v", v.TargetRunID)
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", *(v.TaskList))
		i++
	}
	if v.TargetChildWorkflowOnly != nil {
		fields[i] = fmt.Sprintf("TargetChildWorkflowOnly: %v", *(v.TargetChildWorkflowOnly))
		i++
	}
	if v.ScheduleID != nil {
		fields[i] = fmt.Sprintf("ScheduleID: %v", *(v.ScheduleID))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.VisibilityTimestampNanos != nil {
		fields[i] = fmt.Sprintf("VisibilityTimestampNanos: %v", *(v.VisibilityTimestampNanos))
		i++
	}
	if v.TargetDomainIDs != nil {
		fields[i] = fmt.Sprintf("TargetDomainIDs: %v", v.TargetDomainIDs)
		i++
	}

	return fmt.Sprintf("TransferTaskInfo{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Binary_sliceType_Equals(lhs, rhs [][]byte) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if bytes.Equal(x, y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this TransferTaskInfo match the
// provided TransferTaskInfo.
//
// This function performs a deep comparison.
func (v *TransferTaskInfo) Equals(rhs *TransferTaskInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.DomainID == nil && rhs.DomainID == nil) || (v.DomainID != nil && rhs.DomainID != nil && bytes.Equal(v.DomainID, rhs.DomainID))) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !((v.RunID == nil && rhs.RunID == nil) || (v.RunID != nil && rhs.RunID != nil && bytes.Equal(v.RunID, rhs.RunID))) {
		return false
	}
	if !_I16_EqualsPtr(v.TaskType, rhs.TaskType) {
		return false
	}
	if !((v.TargetDomainID == nil && rhs.TargetDomainID == nil) || (v.TargetDomainID != nil && rhs.TargetDomainID != nil && bytes.Equal(v.TargetDomainID, rhs.TargetDomainID))) {
		return false
	}
	if !_String_EqualsPtr(v.TargetWorkflowID, rhs.TargetWorkflowID) {
		return false
	}
	if !((v.TargetRunID == nil && rhs.TargetRunID == nil) || (v.TargetRunID != nil && rhs.TargetRunID != nil && bytes.Equal(v.TargetRunID, rhs.TargetRunID))) {
		return false
	}
	if !_String_EqualsPtr(v.TaskList, rhs.TaskList) {
		return false
	}
	if !_Bool_EqualsPtr(v.TargetChildWorkflowOnly, rhs.TargetChildWorkflowOnly) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduleID, rhs.ScheduleID) {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.VisibilityTimestampNanos, rhs.VisibilityTimestampNanos) {
		return false
	}
	if !((v.TargetDomainIDs == nil && rhs.TargetDomainIDs == nil) || (v.TargetDomainIDs != nil && rhs.TargetDomainIDs != nil && _Set_Binary_sliceType_Equals(v.TargetDomainIDs, rhs.TargetDomainIDs))) {
		return false
	}

	return true
}

type _Set_Binary_sliceType_Zapper [][]byte

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Binary_sliceType_Zapper.
func (s _Set_Binary_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		enc.AppendString(base64.StdEncoding.EncodeToString(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TransferTaskInfo.
func (v *TransferTaskInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.DomainID != nil {
		enc.AddString("domainID", base64.StdEncoding.EncodeToString(v.DomainID))
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", base64.StdEncoding.EncodeToString(v.RunID))
	}
	if v.TaskType != nil {
		enc.AddInt16("taskType", *v.TaskType)
	}
	if v.TargetDomainID != nil {
		enc.AddString("targetDomainID", base64.StdEncoding.EncodeToString(v.TargetDomainID))
	}
	if v.TargetWorkflowID != nil {
		enc.AddString("targetWorkflowID", *v.TargetWorkflowID)
	}
	if v.TargetRunID != nil {
		enc.AddString("targetRunID", base64.StdEncoding.EncodeToString(v.TargetRunID))
	}
	if v.TaskList != nil {
		enc.AddString("taskList", *v.TaskList)
	}
	if v.TargetChildWorkflowOnly != nil {
		enc.AddBool("targetChildWorkflowOnly", *v.TargetChildWorkflowOnly)
	}
	if v.ScheduleID != nil {
		enc.AddInt64("scheduleID", *v.ScheduleID)
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.VisibilityTimestampNanos != nil {
		enc.AddInt64("visibilityTimestampNanos", *v.VisibilityTimestampNanos)
	}
	if v.TargetDomainIDs != nil {
		err = multierr.Append(err, enc.AddArray("targetDomainIDs", (_Set_Binary_sliceType_Zapper)(v.TargetDomainIDs)))
	}
	return err
}

// GetDomainID returns the value of DomainID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetDomainID() (o []byte) {
	if v != nil && v.DomainID != nil {
		return v.DomainID
	}

	return
}

// IsSetDomainID returns true if DomainID is not nil.
func (v *TransferTaskInfo) IsSetDomainID() bool {
	return v != nil && v.DomainID != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *TransferTaskInfo) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetRunID() (o []byte) {
	if v != nil && v.RunID != nil {
		return v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *TransferTaskInfo) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetTaskType returns the value of TaskType if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTaskType() (o int16) {
	if v != nil && v.TaskType != nil {
		return *v.TaskType
	}

	return
}

// IsSetTaskType returns true if TaskType is not nil.
func (v *TransferTaskInfo) IsSetTaskType() bool {
	return v != nil && v.TaskType != nil
}

// GetTargetDomainID returns the value of TargetDomainID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTargetDomainID() (o []byte) {
	if v != nil && v.TargetDomainID != nil {
		return v.TargetDomainID
	}

	return
}

// IsSetTargetDomainID returns true if TargetDomainID is not nil.
func (v *TransferTaskInfo) IsSetTargetDomainID() bool {
	return v != nil && v.TargetDomainID != nil
}

// GetTargetWorkflowID returns the value of TargetWorkflowID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTargetWorkflowID() (o string) {
	if v != nil && v.TargetWorkflowID != nil {
		return *v.TargetWorkflowID
	}

	return
}

// IsSetTargetWorkflowID returns true if TargetWorkflowID is not nil.
func (v *TransferTaskInfo) IsSetTargetWorkflowID() bool {
	return v != nil && v.TargetWorkflowID != nil
}

// GetTargetRunID returns the value of TargetRunID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTargetRunID() (o []byte) {
	if v != nil && v.TargetRunID != nil {
		return v.TargetRunID
	}

	return
}

// IsSetTargetRunID returns true if TargetRunID is not nil.
func (v *TransferTaskInfo) IsSetTargetRunID() bool {
	return v != nil && v.TargetRunID != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTaskList() (o string) {
	if v != nil && v.TaskList != nil {
		return *v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *TransferTaskInfo) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetTargetChildWorkflowOnly returns the value of TargetChildWorkflowOnly if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTargetChildWorkflowOnly() (o bool) {
	if v != nil && v.TargetChildWorkflowOnly != nil {
		return *v.TargetChildWorkflowOnly
	}

	return
}

// IsSetTargetChildWorkflowOnly returns true if TargetChildWorkflowOnly is not nil.
func (v *TransferTaskInfo) IsSetTargetChildWorkflowOnly() bool {
	return v != nil && v.TargetChildWorkflowOnly != nil
}

// GetScheduleID returns the value of ScheduleID if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetScheduleID() (o int64) {
	if v != nil && v.ScheduleID != nil {
		return *v.ScheduleID
	}

	return
}

// IsSetScheduleID returns true if ScheduleID is not nil.
func (v *TransferTaskInfo) IsSetScheduleID() bool {
	return v != nil && v.ScheduleID != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *TransferTaskInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetVisibilityTimestampNanos returns the value of VisibilityTimestampNanos if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetVisibilityTimestampNanos() (o int64) {
	if v != nil && v.VisibilityTimestampNanos != nil {
		return *v.VisibilityTimestampNanos
	}

	return
}

// IsSetVisibilityTimestampNanos returns true if VisibilityTimestampNanos is not nil.
func (v *TransferTaskInfo) IsSetVisibilityTimestampNanos() bool {
	return v != nil && v.VisibilityTimestampNanos != nil
}

// GetTargetDomainIDs returns the value of TargetDomainIDs if it is set or its
// zero value if it is unset.
func (v *TransferTaskInfo) GetTargetDomainIDs() (o [][]byte) {
	if v != nil && v.TargetDomainIDs != nil {
		return v.TargetDomainIDs
	}

	return
}

// IsSetTargetDomainIDs returns true if TargetDomainIDs is not nil.
func (v *TransferTaskInfo) IsSetTargetDomainIDs() bool {
	return v != nil && v.TargetDomainIDs != nil
}

type WorkflowExecutionInfo struct {
	ParentDomainID                          []byte            `json:"parentDomainID,omitempty"`
	ParentWorkflowID                        *string           `json:"parentWorkflowID,omitempty"`
	ParentRunID                             []byte            `json:"parentRunID,omitempty"`
	InitiatedID                             *int64            `json:"initiatedID,omitempty"`
	CompletionEventBatchID                  *int64            `json:"completionEventBatchID,omitempty"`
	CompletionEvent                         []byte            `json:"completionEvent,omitempty"`
	CompletionEventEncoding                 *string           `json:"completionEventEncoding,omitempty"`
	TaskList                                *string           `json:"taskList,omitempty"`
	WorkflowTypeName                        *string           `json:"workflowTypeName,omitempty"`
	WorkflowTimeoutSeconds                  *int32            `json:"workflowTimeoutSeconds,omitempty"`
	DecisionTaskTimeoutSeconds              *int32            `json:"decisionTaskTimeoutSeconds,omitempty"`
	ExecutionContext                        []byte            `json:"executionContext,omitempty"`
	State                                   *int32            `json:"state,omitempty"`
	CloseStatus                             *int32            `json:"closeStatus,omitempty"`
	StartVersion                            *int64            `json:"startVersion,omitempty"`
	LastWriteEventID                        *int64            `json:"lastWriteEventID,omitempty"`
	LastEventTaskID                         *int64            `json:"lastEventTaskID,omitempty"`
	LastFirstEventID                        *int64            `json:"lastFirstEventID,omitempty"`
	LastProcessedEvent                      *int64            `json:"lastProcessedEvent,omitempty"`
	StartTimeNanos                          *int64            `json:"startTimeNanos,omitempty"`
	LastUpdatedTimeNanos                    *int64            `json:"lastUpdatedTimeNanos,omitempty"`
	DecisionVersion                         *int64            `json:"decisionVersion,omitempty"`
	DecisionScheduleID                      *int64            `json:"decisionScheduleID,omitempty"`
	DecisionStartedID                       *int64            `json:"decisionStartedID,omitempty"`
	DecisionTimeout                         *int32            `json:"decisionTimeout,omitempty"`
	DecisionAttempt                         *int64            `json:"decisionAttempt,omitempty"`
	DecisionStartedTimestampNanos           *int64            `json:"decisionStartedTimestampNanos,omitempty"`
	DecisionScheduledTimestampNanos         *int64            `json:"decisionScheduledTimestampNanos,omitempty"`
	CancelRequested                         *bool             `json:"cancelRequested,omitempty"`
	DecisionOriginalScheduledTimestampNanos *int64            `json:"decisionOriginalScheduledTimestampNanos,omitempty"`
	CreateRequestID                         *string           `json:"createRequestID,omitempty"`
	DecisionRequestID                       *string           `json:"decisionRequestID,omitempty"`
	CancelRequestID                         *string           `json:"cancelRequestID,omitempty"`
	StickyTaskList                          *string           `json:"stickyTaskList,omitempty"`
	StickyScheduleToStartTimeout            *int64            `json:"stickyScheduleToStartTimeout,omitempty"`
	RetryAttempt                            *int64            `json:"retryAttempt,omitempty"`
	RetryInitialIntervalSeconds             *int32            `json:"retryInitialIntervalSeconds,omitempty"`
	RetryMaximumIntervalSeconds             *int32            `json:"retryMaximumIntervalSeconds,omitempty"`
	RetryMaximumAttempts                    *int32            `json:"retryMaximumAttempts,omitempty"`
	RetryExpirationSeconds                  *int32            `json:"retryExpirationSeconds,omitempty"`
	RetryBackoffCoefficient                 *float64          `json:"retryBackoffCoefficient,omitempty"`
	RetryExpirationTimeNanos                *int64            `json:"retryExpirationTimeNanos,omitempty"`
	RetryNonRetryableErrors                 []string          `json:"retryNonRetryableErrors,omitempty"`
	HasRetryPolicy                          *bool             `json:"hasRetryPolicy,omitempty"`
	CronSchedule                            *string           `json:"cronSchedule,omitempty"`
	EventStoreVersion                       *int32            `json:"eventStoreVersion,omitempty"`
	EventBranchToken                        []byte            `json:"eventBranchToken,omitempty"`
	SignalCount                             *int64            `json:"signalCount,omitempty"`
	HistorySize                             *int64            `json:"historySize,omitempty"`
	ClientLibraryVersion                    *string           `json:"clientLibraryVersion,omitempty"`
	ClientFeatureVersion                    *string           `json:"clientFeatureVersion,omitempty"`
	ClientImpl                              *string           `json:"clientImpl,omitempty"`
	AutoResetPoints                         []byte            `json:"autoResetPoints,omitempty"`
	AutoResetPointsEncoding                 *string           `json:"autoResetPointsEncoding,omitempty"`
	SearchAttributes                        map[string][]byte `json:"searchAttributes,omitempty"`
	Memo                                    map[string][]byte `json:"memo,omitempty"`
	VersionHistories                        []byte            `json:"versionHistories,omitempty"`
	VersionHistoriesEncoding                *string           `json:"versionHistoriesEncoding,omitempty"`
	FirstExecutionRunID                     []byte            `json:"firstExecutionRunID,omitempty"`
	PartitionConfig                         map[string]string `json:"partitionConfig,omitempty"`
	Checksum                                []byte            `json:"checksum,omitempty"`
	ChecksumEncoding                        *string           `json:"checksumEncoding,omitempty"`
}

type _Map_String_Binary_MapItemList map[string][]byte

func (m _Map_String_Binary_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string][]byte', key [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueBinary(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Binary_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Binary_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) Close() {}

// ToWire translates a WorkflowExecutionInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//	x, err := v.ToWire()
//	if err != nil {
//	  return err
//	}
//
//	if err := binaryProtocol.Encode(x, writer); err != nil {
//	  return err
//	}
func (v *WorkflowExecutionInfo) ToWire() (wire.Value, error) {
	var (
		fields [62]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ParentDomainID != nil {
		w, err = wire.NewValueBinary(v.ParentDomainID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ParentWorkflowID != nil {
		w, err = wire.NewValueString(*(v.ParentWorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ParentRunID != nil {
		w, err = wire.NewValueBinary(v.ParentRunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.InitiatedID != nil {
		w, err = wire.NewValueI64(*(v.InitiatedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.CompletionEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.CompletionEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.CompletionEvent != nil {
		w, err = wire.NewValueBinary(v.CompletionEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.CompletionEventEncoding != nil {
		w, err = wire.NewValueString(*(v.CompletionEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = wire.NewValueString(*(v.TaskList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.WorkflowTypeName != nil {
		w, err = wire.NewValueString(*(v.WorkflowTypeName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.WorkflowTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.WorkflowTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.DecisionTaskTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.DecisionTaskTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ExecutionContext != nil {
		w, err = wire.NewValueBinary(v.ExecutionContext), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.State != nil {
		w, err = wire.NewValueI32(*(v.State)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.CloseStatus != nil {
		w, err = wire.NewValueI32(*(v.CloseStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 36, Value: w}
		i++
	}
	if v.StartVersion != nil {
		w, err = wire.NewValueI64(*(v.StartVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}
	if v.LastWriteEventID != nil {
		w, err = wire.NewValueI64(*(v.LastWriteEventID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 44, Value: w}
		i++
	}
	if v.LastEventTaskID != nil {
		w, err = wire.NewValueI64(*(v.LastEventTaskID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 48, Value: w}
		i++
	}
	if v.LastFirstEventID != nil {
		w, err = wire.NewValueI64(*(v.LastFirstEventID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.LastProcessedEvent != nil {
		w, err = wire.NewValueI64(*(v.LastProcessedEvent)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 52, Value: w}
		i++
	}
	if v.StartTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.StartTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 54, Value: w}
		i++
	}
	if v.LastUpdatedTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.LastUpdatedTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 56, Value: w}
		i++
	}
	if v.DecisionVersion != nil {
		w, err = wire.NewValueI64(*(v.DecisionVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 58, Value: w}
		i++
	}
	if v.DecisionScheduleID != nil {
		w, err = wire.NewValueI64(*(v.DecisionScheduleID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.DecisionStartedID != nil {
		w, err = wire.NewValueI64(*(v.DecisionStartedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 62, Value: w}
		i++
	}
	if v.DecisionTimeout != nil {
		w, err = wire.NewValueI32(*(v.DecisionTimeout)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 64, Value: w}
		i++
	}
	if v.DecisionAttempt != nil {
		w, err = wire.NewValueI64(*(v.DecisionAttempt)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 66, Value: w}
		i++
	}
	if v.DecisionStartedTimestampNanos != nil {
		w, err = wire.NewValueI64(*(v.DecisionStartedTimestampNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 68, Value: w}
		i++
	}
	if v.DecisionScheduledTimestampNanos != nil {
		w, err = wire.NewValueI64(*(v.DecisionScheduledTimestampNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 69, Value: w}
		i++
	}
	if v.CancelRequested != nil {
		w, err = wire.NewValueBool(*(v.CancelRequested)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}
	if v.DecisionOriginalScheduledTimestampNanos != nil {
		w, err = wire.NewValueI64(*(v.DecisionOriginalScheduledTimestampNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 71, Value: w}
		i++
	}
	if v.CreateRequestID != nil {
		w, err = wire.NewValueString(*(v.CreateRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 72, Value: w}
		i++
	}
	if v.DecisionRequestID != nil {
		w, err = wire.NewValueString(*(v.DecisionRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 74, Value: w}
		i++
	}
	if v.CancelRequestID != nil {
		w, err = wire.NewValueString(*(v.CancelRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 76, Value: w}
		i++
	}
	if v.StickyTaskList != nil {
		w, err = wire.NewValueString(*(v.StickyTaskList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 78, Value: w}
		i++
	}
	if v.StickyScheduleToStartTimeout != nil {
		w, err = wire.NewValueI64(*(v.StickyScheduleToStartTimeout)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 80, Value: w}
		i++
	}
	if v.RetryAttempt != nil {
		w, err = wire.NewValueI64(*(v.RetryAttempt)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 82, Value: w}
		i++
	}
	if v.RetryInitialIntervalSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryInitialIntervalSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 84, Value: w}
		i++
	}
	if v.RetryMaximumIntervalSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryMaximumIntervalSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 86, Value: w}
		i++
	}
	if v.RetryMaximumAttempts != nil {
		w, err = wire.NewValueI32(*(v.RetryMaximumAttempts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 88, Value: w}
		i++
	}
	if v.RetryExpirationSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryExpirationSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 90, Value: w}
		i++
	}
	if v.RetryBackoffCoefficient != nil {
		w, err = wire.NewValueDouble(*(v.RetryBackoffCoefficient)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 92, Value: w}
		i++
	}
	if v.RetryExpirationTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.RetryExpirationTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 94, Value: w}
		i++
	}
	if v.RetryNonRetryableErrors != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.RetryNonRetryableErrors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 96, Value: w}
		i++
	}
	if v.HasRetryPolicy != nil {
		w, err = wire.NewValueBool(*(v.HasRetryPolicy)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 98, Value: w}
		i++
	}
	if v.CronSchedule != nil {
		w, err = wire.NewValueString(*(v.CronSchedule)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 100, Value: w}
		i++
	}
	if v.EventStoreVersion != nil {
		w, err = wire.NewValueI32(*(v.EventStoreVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 102, Value: w}
		i++
	}
	if v.EventBranchToken != nil {
		w, err = wire.NewValueBinary(v.EventBranchToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 104, Value: w}
		i++
	}
	if v.SignalCount != nil {
		w, err = wire.NewValueI64(*(v.SignalCount)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 106, Value: w}
		i++
	}
	if v.HistorySize != nil {
		w, err = wire.NewValueI64(*(v.HistorySize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 108, Value: w}
		i++
	}
	if v.ClientLibraryVersion != nil {
		w, err = wire.NewValueString(*(v.ClientLibraryVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 110, Value: w}
		i++
	}
	if v.ClientFeatureVersion != nil {
		w, err = wire.NewValueString(*(v.ClientFeatureVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 112, Value: w}
		i++
	}
	if v.ClientImpl != nil {
		w, err = wire.NewValueString(*(v.ClientImpl)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 114, Value: w}
		i++
	}
	if v.AutoResetPoints != nil {
		w, err = wire.NewValueBinary(v.AutoResetPoints), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 115, Value: w}
		i++
	}
	if v.AutoResetPointsEncoding != nil {
		w, err = wire.NewValueString(*(v.AutoResetPointsEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 116, Value: w}
		i++
	}
	if v.SearchAttributes != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.SearchAttributes)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 118, Value: w}
		i++
	}
	if v.Memo != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.Memo)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 120, Value: w}
		i++
	}
	if v.VersionHistories != nil {
		w, err = wire.NewValueBinary(v.VersionHistories), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 122, Value: w}
		i++
	}
	if v.VersionHistoriesEncoding != nil {
		w, err = wire.NewValueString(*(v.VersionHistoriesEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 124, Value: w}
		i++
	}
	if v.FirstExecutionRunID != nil {
		w, err = wire.NewValueBinary(v.FirstExecutionRunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 126, Value: w}
		i++
	}
	if v.PartitionConfig != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.PartitionConfig)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 128, Value: w}
		i++
	}
	if v.Checksum != nil {
		w, err = wire.NewValueBinary(v.Checksum), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 130, Value: w}
		i++
	}
	if v.ChecksumEncoding != nil {
		w, err = wire.NewValueString(*(v.ChecksumEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 132, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_Binary_Read(m wire.MapItemList) (map[string][]byte, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string][]byte, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetBinary(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a WorkflowExecutionInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowExecutionInfo struct
// from the provided intermediate representation.
//
//	x, err := binaryProtocol.Decode(reader, wire.TStruct)
//	if err != nil {
//	  return nil, err
//	}
//
//	var v WorkflowExecutionInfo
//	if err := v.FromWire(x); err != nil {
//	  return nil, err
//	}
//	return &v, nil
func (v *WorkflowExecutionInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.ParentDomainID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ParentWorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				v.ParentRunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.InitiatedID = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CompletionEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.CompletionEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CompletionEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TaskList = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowTypeName = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.WorkflowTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.DecisionTaskTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TBinary {
				v.ExecutionContext, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.State = &x
				if err != nil {
					return err
				}

			}
		case 36:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.CloseStatus = &x
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartVersion = &x
				if err != nil {
					return err
				}

			}
		case 44:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastWriteEventID = &x
				if err != nil {
					return err
				}

			}
		case 48:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastEventTaskID = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastFirstEventID = &x
				if err != nil {
					return err
				}

			}
		case 52:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastProcessedEvent = &x
				if err != nil {
					return err
				}

			}
		case 54:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 56:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastUpdatedTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 58:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionVersion = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionScheduleID = &x
				if err != nil {
					return err
				}

			}
		case 62:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionStartedID = &x
				if err != nil {
					return err
				}

			}
		case 64:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.DecisionTimeout = &x
				if err != nil {
					return err
				}

			}
		case 66:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionAttempt = &x
				if err != nil {
					return err
				}

			}
		case 68:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionStartedTimestampNanos = &x
				if err != nil {
					return err
				}

			}
		case 69:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionScheduledTimestampNanos = &x
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CancelRequested = &x
				if err != nil {
					return err
				}

			}
		case 71:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionOriginalScheduledTimestampNanos = &x
				if err != nil {
					return err
				}

			}
		case 72:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CreateRequestID = &x
				if err != nil {
					return err
				}

			}
		case 74:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.DecisionRequestID = &x
				if err != nil {
					return err
				}

			}
		case 76:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CancelRequestID = &x
				if err != nil {
					return err
				}

			}
		case 78:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StickyTaskList = &x
				if err != nil {
					return err
				}

			}
		case 80:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StickyScheduleToStartTimeout = &x
				if err != nil {
					return err
				}

			}
		case 82:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RetryAttempt = &x
				if err != nil {
					return err
				}

			}
		case 84:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryInitialIntervalSeconds = &x
				if err != nil {
					return err
				}

			}
		case 86:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryMaximumIntervalSeconds = &x
				if err != nil {
					return err
				}

			}
		case 88:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryMaximumAttempts = &x
				if err != nil {
					return err
				}

			}
		case 90:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryExpirationSeconds = &x
				if err != nil {
					return err
				}

			}
		case 92:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.RetryBackoffCoefficient = &x
				if err != nil {
					return err
				}

			}
		case 94:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RetryExpirationTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 96:
			if field.Value.Type() == wire.TList {
				v.RetryNonRetryableErrors, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 98:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.HasRetryPolicy = &x
				if err != nil {
					return err
				}

			}
		case 100:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CronSchedule = &x
				if err != nil {
					return err
				}

			}
		case 102:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EventStoreVersion = &x
				if err != nil {
					return err
				}

			}
		case 104:
			if field.Value.Type() == wire.TBinary {
				v.EventBranchToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 106:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.SignalCount = &x
				if err != nil {
					return err
				}

			}
		case 108:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.HistorySize = &x
				if err != nil {
					return err
				}

			}
		case 110:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ClientLibraryVersion = &x
				if err != nil {
					return err
				}

			}
		case 112:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ClientFeatureVersion = &x
				if err != nil {
					return err
				}

			}
		case 114:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ClientImpl = &x
				if err != nil {
					return err
				}

			}
		case 115:
			if field.Value.Type() == wire.TBinary {
				v.AutoResetPoints, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 116:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AutoResetPointsEncoding = &x
				if err != nil {
					return err
				}

			}
		case 118:
			if field.Value.Type() == wire.TMap {
				v.SearchAttributes, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 120:
			if field.Value.Type() == wire.TMap {
				v.Memo, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 122:
			if field.Value.Type() == wire.TBinary {
				v.VersionHistories, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 124:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.VersionHistoriesEncoding = &x
				if err != nil {
					return err
				}

			}
		case 126:
			if field.Value.Type() == wire.TBinary {
				v.FirstExecutionRunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 128:
			if field.Value.Type() == wire.TMap {
				v.PartitionConfig, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 130:
			if field.Value.Type() == wire.TBinary {
				v.Checksum, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 132:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ChecksumEncoding = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Map_String_Binary_Encode(val map[string][]byte, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TBinary,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string][]byte', key [%v]: value is nil", k)
		}
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := sw.WriteBinary(v); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

// Encode serializes a WorkflowExecutionInfo struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a WorkflowExecutionInfo struct could not be encoded.
func (v *WorkflowExecutionInfo) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ParentDomainID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 10, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.ParentDomainID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ParentWorkflowID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 12, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ParentWorkflowID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ParentRunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 14, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.ParentRunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.InitiatedID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 16, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.InitiatedID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CompletionEventBatchID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 18, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.CompletionEventBatchID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CompletionEvent != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 20, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.CompletionEvent); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CompletionEventEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 22, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CompletionEventEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TaskList != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 24, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.TaskList)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WorkflowTypeName != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 26, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.WorkflowTypeName)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.WorkflowTimeoutSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 28, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.WorkflowTimeoutSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionTaskTimeoutSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 30, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.DecisionTaskTimeoutSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ExecutionContext != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 32, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.ExecutionContext); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.State != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 34, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.State)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CloseStatus != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 36, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.CloseStatus)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 38, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StartVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastWriteEventID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 44, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastWriteEventID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastEventTaskID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 48, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastEventTaskID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastFirstEventID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 50, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastFirstEventID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastProcessedEvent != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 52, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastProcessedEvent)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StartTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 54, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StartTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LastUpdatedTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 56, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.LastUpdatedTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 58, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionScheduleID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 60, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionScheduleID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionStartedID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 62, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionStartedID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionTimeout != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 64, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.DecisionTimeout)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionAttempt != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 66, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionAttempt)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionStartedTimestampNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 68, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionStartedTimestampNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionScheduledTimestampNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 69, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionScheduledTimestampNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CancelRequested != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 70, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.CancelRequested)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionOriginalScheduledTimestampNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 71, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.DecisionOriginalScheduledTimestampNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CreateRequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 72, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CreateRequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DecisionRequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 74, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.DecisionRequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CancelRequestID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 76, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CancelRequestID)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StickyTaskList != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 78, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.StickyTaskList)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StickyScheduleToStartTimeout != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 80, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.StickyScheduleToStartTimeout)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryAttempt != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 82, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.RetryAttempt)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryInitialIntervalSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 84, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryInitialIntervalSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryMaximumIntervalSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 86, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryMaximumIntervalSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryMaximumAttempts != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 88, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryMaximumAttempts)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryExpirationSeconds != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 90, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.RetryExpirationSeconds)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryBackoffCoefficient != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 92, Type: wire.TDouble}); err != nil {
			return err
		}
		if err := sw.WriteDouble(*(v.RetryBackoffCoefficient)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryExpirationTimeNanos != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 94, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.RetryExpirationTimeNanos)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.RetryNonRetryableErrors != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 96, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.RetryNonRetryableErrors, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.HasRetryPolicy != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 98, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.HasRetryPolicy)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CronSchedule != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 100, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.CronSchedule)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EventStoreVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 102, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.EventStoreVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EventBranchToken != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 104, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.EventBranchToken); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.SignalCount != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 106, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.SignalCount)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.HistorySize != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 108, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.HistorySize)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientLibraryVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 110, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ClientLibraryVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientFeatureVersion != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 112, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ClientFeatureVersion)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientImpl != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 114, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ClientImpl)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.AutoResetPoints != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 115, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.AutoResetPoints); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.AutoResetPointsEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 116, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.AutoResetPointsEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.SearchAttributes != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 118, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_Binary_Encode(v.SearchAttributes, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Memo != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 120, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_Binary_Encode(v.Memo, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.VersionHistories != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 122, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.VersionHistories); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.VersionHistoriesEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 124, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.VersionHistoriesEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FirstExecutionRunID != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 126, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.FirstExecutionRunID); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.PartitionConfig != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 128, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_String_Encode(v.PartitionConfig, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Checksum != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 130, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.Checksum); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ChecksumEncoding != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 132, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.ChecksumEncoding)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Map_String_Binary_Decode(sr stream.Reader) (map[string][]byte, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TBinary {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string][]byte, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := sr.ReadBinary()
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a WorkflowExecutionInfo struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a WorkflowExecutionInfo struct could not be generated from the wire
// representation.
func (v *WorkflowExecutionInfo) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 10 && fh.Type == wire.TBinary:
			v.ParentDomainID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 12 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ParentWorkflowID = &x
			if err != nil {
				return err
			}

		case fh.ID == 14 && fh.Type == wire.TBinary:
			v.ParentRunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 16 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.InitiatedID = &x
			if err != nil {
				return err
			}

		case fh.ID == 18 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.CompletionEventBatchID = &x
			if err != nil {
				return err
			}

		case fh.ID == 20 && fh.Type == wire.TBinary:
			v.CompletionEvent, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 22 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CompletionEventEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 24 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.TaskList = &x
			if err != nil {
				return err
			}

		case fh.ID == 26 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.WorkflowTypeName = &x
			if err != nil {
				return err
			}

		case fh.ID == 28 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.WorkflowTimeoutSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 30 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.DecisionTaskTimeoutSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 32 && fh.Type == wire.TBinary:
			v.ExecutionContext, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 34 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.State = &x
			if err != nil {
				return err
			}

		case fh.ID == 36 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.CloseStatus = &x
			if err != nil {
				return err
			}

		case fh.ID == 38 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StartVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 44 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastWriteEventID = &x
			if err != nil {
				return err
			}

		case fh.ID == 48 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastEventTaskID = &x
			if err != nil {
				return err
			}

		case fh.ID == 50 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastFirstEventID = &x
			if err != nil {
				return err
			}

		case fh.ID == 52 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastProcessedEvent = &x
			if err != nil {
				return err
			}

		case fh.ID == 54 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StartTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 56 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.LastUpdatedTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 58 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 60 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionScheduleID = &x
			if err != nil {
				return err
			}

		case fh.ID == 62 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionStartedID = &x
			if err != nil {
				return err
			}

		case fh.ID == 64 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.DecisionTimeout = &x
			if err != nil {
				return err
			}

		case fh.ID == 66 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionAttempt = &x
			if err != nil {
				return err
			}

		case fh.ID == 68 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionStartedTimestampNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 69 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionScheduledTimestampNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 70 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.CancelRequested = &x
			if err != nil {
				return err
			}

		case fh.ID == 71 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.DecisionOriginalScheduledTimestampNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 72 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CreateRequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 74 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.DecisionRequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 76 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CancelRequestID = &x
			if err != nil {
				return err
			}

		case fh.ID == 78 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.StickyTaskList = &x
			if err != nil {
				return err
			}

		case fh.ID == 80 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.StickyScheduleToStartTimeout = &x
			if err != nil {
				return err
			}

		case fh.ID == 82 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.RetryAttempt = &x
			if err != nil {
				return err
			}

		case fh.ID == 84 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryInitialIntervalSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 86 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryMaximumIntervalSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 88 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryMaximumAttempts = &x
			if err != nil {
				return err
			}

		case fh.ID == 90 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.RetryExpirationSeconds = &x
			if err != nil {
				return err
			}

		case fh.ID == 92 && fh.Type == wire.TDouble:
			var x float64
			x, err = sr.ReadDouble()
			v.RetryBackoffCoefficient = &x
			if err != nil {
				return err
			}

		case fh.ID == 94 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.RetryExpirationTimeNanos = &x
			if err != nil {
				return err
			}

		case fh.ID == 96 && fh.Type == wire.TList:
			v.RetryNonRetryableErrors, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 98 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.HasRetryPolicy = &x
			if err != nil {
				return err
			}

		case fh.ID == 100 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.CronSchedule = &x
			if err != nil {
				return err
			}

		case fh.ID == 102 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.EventStoreVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 104 && fh.Type == wire.TBinary:
			v.EventBranchToken, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 106 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.SignalCount = &x
			if err != nil {
				return err
			}

		case fh.ID == 108 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.HistorySize = &x
			if err != nil {
				return err
			}

		case fh.ID == 110 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ClientLibraryVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 112 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ClientFeatureVersion = &x
			if err != nil {
				return err
			}

		case fh.ID == 114 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ClientImpl = &x
			if err != nil {
				return err
			}

		case fh.ID == 115 && fh.Type == wire.TBinary:
			v.AutoResetPoints, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 116 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.AutoResetPointsEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 118 && fh.Type == wire.TMap:
			v.SearchAttributes, err = _Map_String_Binary_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 120 && fh.Type == wire.TMap:
			v.Memo, err = _Map_String_Binary_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 122 && fh.Type == wire.TBinary:
			v.VersionHistories, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 124 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.VersionHistoriesEncoding = &x
			if err != nil {
				return err
			}

		case fh.ID == 126 && fh.Type == wire.TBinary:
			v.FirstExecutionRunID, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 128 && fh.Type == wire.TMap:
			v.PartitionConfig, err = _Map_String_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 130 && fh.Type == wire.TBinary:
			v.Checksum, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 132 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.ChecksumEncoding = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a WorkflowExecutionInfo
// struct.
func (v *WorkflowExecutionInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [62]string
	i := 0
	if v.ParentDomainID != nil {
		fields[i] = fmt.Sprintf("ParentDomainID: %v", v.ParentDomainID)
		i++
	}
	if v.ParentWorkflowID != nil {
		fields[i] = fmt.Sprintf("ParentWorkflowID: %v", *(v.ParentWorkflowID))
		i++
	}
	if v.ParentRunID != nil {
		fields[i] = fmt.Sprintf("ParentRunID: %v", v.ParentRunID)
		i++
	}
	if v.InitiatedID != nil {
		fields[i] = fmt.Sprintf("InitiatedID: %v", *(v.InitiatedID))
		i++
	}
	if v.CompletionEventBatchID != nil {
		fields[i] = fmt.Sprintf("CompletionEventBatchID: %v", *(v.CompletionEventBatchID))
		i++
	}
	if v.CompletionEvent != nil {
		fields[i] = fmt.Sprintf("CompletionEvent: %v", v.CompletionEvent)
		i++
	}
	if v.CompletionEventEncoding != nil {
		fields[i] = fmt.Sprintf("CompletionEventEncoding: %v", *(v.CompletionEventEncoding))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", *(v.TaskList))
		i++
	}
	if v.WorkflowTypeName != nil {
		fields[i] = fmt.Sprintf("WorkflowTypeName: %v", *(v.WorkflowTypeName))
		i++
	}
	if v.WorkflowTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("WorkflowTimeoutSeconds: %v", *(v.WorkflowTimeoutSeconds))
		i++
	}
	if v.DecisionTaskTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("DecisionTaskTimeoutSeconds: %v", *(v.DecisionTaskTimeoutSeconds))
		i++
	}
	if v.ExecutionContext != nil {
		fields[i] = fmt.Sprintf("ExecutionContext: %v", v.ExecutionContext)
		i++
	}
	if v.State != nil {
		fields[i] = fmt.Sprintf("State: %v", *(v.State))
		i++
	}
	if v.CloseStatus != nil {
		fields[i] = fmt.Sprintf("CloseStatus: %v", *(v.CloseStatus))
		i++
	}
	if v.StartVersion != nil {
		fields[i] = fmt.Sprintf("StartVersion: %v", *(v.StartVersion))
		i++
	}
	if v.LastWriteEventID != nil {
		fields[i] = fmt.Sprintf("LastWriteEventID: %v", *(v.LastWriteEventID))
		i++
	}
	if v.LastEventTaskID != nil {
		fields[i] = fmt.Sprintf("LastEventTaskID: %v", *(v.LastEventTaskID))
		i++
	}
	if v.LastFirstEventID != nil {
		fields[i] = fmt.Sprintf("LastFirstEventID: %v", *(v.LastFirstEventID))
		i++
	}
	if v.LastProcessedEvent != nil {
		fields[i] = fmt.Sprintf("LastProcessedEvent: %v", *(v.LastProcessedEvent))
		i++
	}
	if v.StartTimeNanos != nil {
		fields[i] = fmt.Sprintf("StartTimeNanos: %v", *(v.StartTimeNanos))
		i++
	}
	if v.LastUpdatedTimeNanos != nil {
		fields[i] = fmt.Sprintf("LastUpdatedTimeNanos: %v", *(v.LastUpdatedTimeNanos))
		i++
	}
	if v.DecisionVersion != nil {
		fields[i] = fmt.Sprintf("DecisionVersion: %v", *(v.DecisionVersion))
		i++
	}
	if v.DecisionScheduleID != nil {
		fields[i] = fmt.Sprintf("DecisionScheduleID: %v", *(v.DecisionScheduleID))
		i++
	}
	if v.DecisionStartedID != nil {
		fields[i] = fmt.Sprintf("DecisionStartedID: %v", *(v.DecisionStartedID))
		i++
	}
	if v.DecisionTimeout != nil {
		fields[i] = fmt.Sprintf("DecisionTimeout: %v", *(v.DecisionTimeout))
		i++
	}
	if v.DecisionAttempt != nil {
		fields[i] = fmt.Sprintf("DecisionAttempt: %v", *(v.DecisionAttempt))
		i++
	}
	if v.DecisionStartedTimestampNanos != nil {
		fields[i] = fmt.Sprintf("DecisionStartedTimestampNanos: %v", *(v.DecisionStartedTimestampNanos))
		i++
	}
	if v.DecisionScheduledTimestampNanos != nil {
		fields[i] = fmt.Sprintf("DecisionScheduledTimestampNanos: %v", *(v.DecisionScheduledTimestampNanos))
		i++
	}
	if v.CancelRequested != nil {
		fields[i] = fmt.Sprintf("CancelRequested: %v", *(v.CancelRequested))
		i++
	}
	if v.DecisionOriginalScheduledTimestampNanos != nil {
		fields[i] = fmt.Sprintf("DecisionOriginalScheduledTimestampNanos: %v", *(v.DecisionOriginalScheduledTimestampNanos))
		i++
	}
	if v.CreateRequestID != nil {
		fields[i] = fmt.Sprintf("CreateRequestID: %v", *(v.CreateRequestID))
		i++
	}
	if v.DecisionRequestID != nil {
		fields[i] = fmt.Sprintf("DecisionRequestID: %v", *(v.DecisionRequestID))
		i++
	}
	if v.CancelRequestID != nil {
		fields[i] = fmt.Sprintf("CancelRequestID: %v", *(v.CancelRequestID))
		i++
	}
	if v.StickyTaskList != nil {
		fields[i] = fmt.Sprintf("StickyTaskList: %v", *(v.StickyTaskList))
		i++
	}
	if v.StickyScheduleToStartTimeout != nil {
		fields[i] = fmt.Sprintf("StickyScheduleToStartTimeout: %v", *(v.StickyScheduleToStartTimeout))
		i++
	}
	if v.RetryAttempt != nil {
		fields[i] = fmt.Sprintf("RetryAttempt: %v", *(v.RetryAttempt))
		i++
	}
	if v.RetryInitialIntervalSeconds != nil {
		fields[i] = fmt.Sprintf("RetryInitialIntervalSeconds: %v", *(v.RetryInitialIntervalSeconds))
		i++
	}
	if v.RetryMaximumIntervalSeconds != nil {
		fields[i] = fmt.Sprintf("RetryMaximumIntervalSeconds: %v", *(v.RetryMaximumIntervalSeconds))
		i++
	}
	if v.RetryMaximumAttempts != nil {
		fields[i] = fmt.Sprintf("RetryMaximumAttempts: %v", *(v.RetryMaximumAttempts))
		i++
	}
	if v.RetryExpirationSeconds != nil {
		fields[i] = fmt.Sprintf("RetryExpirationSeconds: %v", *(v.RetryExpirationSeconds))
		i++
	}
	if v.RetryBackoffCoefficient != nil {
		fields[i] = fmt.Sprintf("RetryBackoffCoefficient: %v", *(v.RetryBackoffCoefficient))
		i++
	}
	if v.RetryExpirationTimeNanos != nil {
		fields[i] = fmt.Sprintf("RetryExpirationTimeNanos: %v", *(v.RetryExpirationTimeNanos))
		i++
	}
	if v.RetryNonRetryableErrors != nil {
		fields[i] = fmt.Sprintf("RetryNonRetryableErrors: %v", v.RetryNonRetryableErrors)
		i++
	}
	if v.HasRetryPolicy != nil {
		fields[i] = fmt.Sprintf("HasRetryPolicy: %v", *(v.HasRetryPolicy))
		i++
	}
	if v.CronSchedule != nil {
		fields[i] = fmt.Sprintf("CronSchedule: %v", *(v.CronSchedule))
		i++
	}
	if v.EventStoreVersion != nil {
		fields[i] = fmt.Sprintf("EventStoreVersion: %v", *(v.EventStoreVersion))
		i++
	}
	if v.EventBranchToken != nil {
		fields[i] = fmt.Sprintf("EventBranchToken: %v", v.EventBranchToken)
		i++
	}
	if v.SignalCount != nil {
		fields[i] = fmt.Sprintf("SignalCount: %v", *(v.SignalCount))
		i++
	}
	if v.HistorySize != nil {
		fields[i] = fmt.Sprintf("HistorySize: %v", *(v.HistorySize))
		i++
	}
	if v.ClientLibraryVersion != nil {
		fields[i] = fmt.Sprintf("ClientLibraryVersion: %v", *(v.ClientLibraryVersion))
		i++
	}
	if v.ClientFeatureVersion != nil {
		fields[i] = fmt.Sprintf("ClientFeatureVersion: %v", *(v.ClientFeatureVersion))
		i++
	}
	if v.ClientImpl != nil {
		fields[i] = fmt.Sprintf("ClientImpl: %v", *(v.ClientImpl))
		i++
	}
	if v.AutoResetPoints != nil {
		fields[i] = fmt.Sprintf("AutoResetPoints: %v", v.AutoResetPoints)
		i++
	}
	if v.AutoResetPointsEncoding != nil {
		fields[i] = fmt.Sprintf("AutoResetPointsEncoding: %v", *(v.AutoResetPointsEncoding))
		i++
	}
	if v.SearchAttributes != nil {
		fields[i] = fmt.Sprintf("SearchAttributes: %v", v.SearchAttributes)
		i++
	}
	if v.Memo != nil {
		fields[i] = fmt.Sprintf("Memo: %v", v.Memo)
		i++
	}
	if v.VersionHistories != nil {
		fields[i] = fmt.Sprintf("VersionHistories: %v", v.VersionHistories)
		i++
	}
	if v.VersionHistoriesEncoding != nil {
		fields[i] = fmt.Sprintf("VersionHistoriesEncoding: %v", *(v.VersionHistoriesEncoding))
		i++
	}
	if v.FirstExecutionRunID != nil {
		fields[i] = fmt.Sprintf("FirstExecutionRunID: %v", v.FirstExecutionRunID)
		i++
	}
	if v.PartitionConfig != nil {
		fields[i] = fmt.Sprintf("PartitionConfig: %v", v.PartitionConfig)
		i++
	}
	if v.Checksum != nil {
		fields[i] = fmt.Sprintf("Checksum: %v", v.Checksum)
		i++
	}
	if v.ChecksumEncoding != nil {
		fields[i] = fmt.Sprintf("ChecksumEncoding: %v", *(v.ChecksumEncoding))
		i++
	}

	return fmt.Sprintf("WorkflowExecutionInfo{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_Binary_Equals(lhs, rhs map[string][]byte) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !bytes.Equal(lv, rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this WorkflowExecutionInfo match the
// provided WorkflowExecutionInfo.
//
// This function performs a deep comparison.
func (v *WorkflowExecutionInfo) Equals(rhs *WorkflowExecutionInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ParentDomainID == nil && rhs.ParentDomainID == nil) || (v.ParentDomainID != nil && rhs.ParentDomainID != nil && bytes.Equal(v.ParentDomainID, rhs.ParentDomainID))) {
		return false
	}
	if !_String_EqualsPtr(v.ParentWorkflowID, rhs.ParentWorkflowID) {
		return false
	}
	if !((v.ParentRunID == nil && rhs.ParentRunID == nil) || (v.ParentRunID != nil && rhs.ParentRunID != nil && bytes.Equal(v.ParentRunID, rhs.ParentRunID))) {
		return false
	}
	if !_I64_EqualsPtr(v.InitiatedID, rhs.InitiatedID) {
		return false
	}
	if !_I64_EqualsPtr(v.CompletionEventBatchID, rhs.CompletionEventBatchID) {
		return false
	}
	if !((v.CompletionEvent == nil && rhs.CompletionEvent == nil) || (v.CompletionEvent != nil && rhs.CompletionEvent != nil && bytes.Equal(v.CompletionEvent, rhs.CompletionEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.CompletionEventEncoding, rhs.CompletionEventEncoding) {
		return false
	}
	if !_String_EqualsPtr(v.TaskList, rhs.TaskList) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowTypeName, rhs.WorkflowTypeName) {
		return false
	}
	if !_I32_EqualsPtr(v.WorkflowTimeoutSeconds, rhs.WorkflowTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.DecisionTaskTimeoutSeconds, rhs.DecisionTaskTimeoutSeconds) {
		return false
	}
	if !((v.ExecutionContext == nil && rhs.ExecutionContext == nil) || (v.ExecutionContext != nil && rhs.ExecutionContext != nil && bytes.Equal(v.ExecutionContext, rhs.ExecutionContext))) {
		return false
	}
	if !_I32_EqualsPtr(v.State, rhs.State) {
		return false
	}
	if !_I32_EqualsPtr(v.CloseStatus, rhs.CloseStatus) {
		return false
	}
	if !_I64_EqualsPtr(v.StartVersion, rhs.StartVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.LastWriteEventID, rhs.LastWriteEventID) {
		return false
	}
	if !_I64_EqualsPtr(v.LastEventTaskID, rhs.LastEventTaskID) {
		return false
	}
	if !_I64_EqualsPtr(v.LastFirstEventID, rhs.LastFirstEventID) {
		return false
	}
	if !_I64_EqualsPtr(v.LastProcessedEvent, rhs.LastProcessedEvent) {
		return false
	}
	if !_I64_EqualsPtr(v.StartTimeNanos, rhs.StartTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.LastUpdatedTimeNanos, rhs.LastUpdatedTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionVersion, rhs.DecisionVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionScheduleID, rhs.DecisionScheduleID) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionStartedID, rhs.DecisionStartedID) {
		return false
	}
	if !_I32_EqualsPtr(v.DecisionTimeout, rhs.DecisionTimeout) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionAttempt, rhs.DecisionAttempt) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionStartedTimestampNanos, rhs.DecisionStartedTimestampNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionScheduledTimestampNanos, rhs.DecisionScheduledTimestampNanos) {
		return false
	}
	if !_Bool_EqualsPtr(v.CancelRequested, rhs.CancelRequested) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionOriginalScheduledTimestampNanos, rhs.DecisionOriginalScheduledTimestampNanos) {
		return false
	}
	if !_String_EqualsPtr(v.CreateRequestID, rhs.CreateRequestID) {
		return false
	}
	if !_String_EqualsPtr(v.DecisionRequestID, rhs.DecisionRequestID) {
		return false
	}
	if !_String_EqualsPtr(v.CancelRequestID, rhs.CancelRequestID) {
		return false
	}
	if !_String_EqualsPtr(v.StickyTaskList, rhs.StickyTaskList) {
		return false
	}
	if !_I64_EqualsPtr(v.StickyScheduleToStartTimeout, rhs.StickyScheduleToStartTimeout) {
		return false
	}
	if !_I64_EqualsPtr(v.RetryAttempt, rhs.RetryAttempt) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryInitialIntervalSeconds, rhs.RetryInitialIntervalSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryMaximumIntervalSeconds, rhs.RetryMaximumIntervalSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryMaximumAttempts, rhs.RetryMaximumAttempts) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryExpirationSeconds, rhs.RetryExpirationSeconds) {
		return false
	}
	if !_Double_EqualsPtr(v.RetryBackoffCoefficient, rhs.RetryBackoffCoefficient) {
		return false
	}
	if !_I64_EqualsPtr(v.RetryExpirationTimeNanos, rhs.RetryExpirationTimeNanos) {
		return false
	}
	if !((v.RetryNonRetryableErrors == nil && rhs.RetryNonRetryableErrors == nil) || (v.RetryNonRetryableErrors != nil && rhs.RetryNonRetryableErrors != nil && _List_String_Equals(v.RetryNonRetryableErrors, rhs.RetryNonRetryableErrors))) {
		return false
	}
	if !_Bool_EqualsPtr(v.HasRetryPolicy, rhs.HasRetryPolicy) {
		return false
	}
	if !_String_EqualsPtr(v.CronSchedule, rhs.CronSchedule) {
		return false
	}
	if !_I32_EqualsPtr(v.EventStoreVersion, rhs.EventStoreVersion) {
		return false
	}
	if !((v.EventBranchToken == nil && rhs.EventBranchToken == nil) || (v.EventBranchToken != nil && rhs.EventBranchToken != nil && bytes.Equal(v.EventBranchToken, rhs.EventBranchToken))) {
		return false
	}
	if !_I64_EqualsPtr(v.SignalCount, rhs.SignalCount) {
		return false
	}
	if !_I64_EqualsPtr(v.HistorySize, rhs.HistorySize) {
		return false
	}
	if !_String_EqualsPtr(v.ClientLibraryVersion, rhs.ClientLibraryVersion) {
		return false
	}
	if !_String_EqualsPtr(v.ClientFeatureVersion, rhs.ClientFeatureVersion) {
		return false
	}
	if !_String_EqualsPtr(v.ClientImpl, rhs.ClientImpl) {
		return false
	}
	if !((v.AutoResetPoints == nil && rhs.AutoResetPoints == nil) || (v.AutoResetPoints != nil && rhs.AutoResetPoints != nil && bytes.Equal(v.AutoResetPoints, rhs.AutoResetPoints))) {
		return false
	}
	if !_String_EqualsPtr(v.AutoResetPointsEncoding, rhs.AutoResetPointsEncoding) {
		return false
	}
	if !((v.SearchAttributes == nil && rhs.SearchAttributes == nil) || (v.SearchAttributes != nil && rhs.SearchAttributes != nil && _Map_String_Binary_Equals(v.SearchAttributes, rhs.SearchAttributes))) {
		return false
	}
	if !((v.Memo == nil && rhs.Memo == nil) || (v.Memo != nil && rhs.Memo != nil && _Map_String_Binary_Equals(v.Memo, rhs.Memo))) {
		return false
	}
	if !((v.VersionHistories == nil && rhs.VersionHistories == nil) || (v.VersionHistories != nil && rhs.VersionHistories != nil && bytes.Equal(v.VersionHistories, rhs.VersionHistories))) {
		return false
	}
	if !_String_EqualsPtr(v.VersionHistoriesEncoding, rhs.VersionHistoriesEncoding) {
		return false
	}
	if !((v.FirstExecutionRunID == nil && rhs.FirstExecutionRunID == nil) || (v.FirstExecutionRunID != nil && rhs.FirstExecutionRunID != nil && bytes.Equal(v.FirstExecutionRunID, rhs.FirstExecutionRunID))) {
		return false
	}
	if !((v.PartitionConfig == nil && rhs.PartitionConfig == nil) || (v.PartitionConfig != nil && rhs.PartitionConfig != nil && _Map_String_String_Equals(v.PartitionConfig, rhs.PartitionConfig))) {
		return false
	}
	if !((v.Checksum == nil && rhs.Checksum == nil) || (v.Checksum != nil && rhs.Checksum != nil && bytes.Equal(v.Checksum, rhs.Checksum))) {
		return false
	}
	if !_String_EqualsPtr(v.ChecksumEncoding, rhs.ChecksumEncoding) {
		return false
	}

	return true
}

type _Map_String_Binary_Zapper map[string][]byte

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_Binary_Zapper.
func (m _Map_String_Binary_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), base64.StdEncoding.EncodeToString(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionInfo.
func (v *WorkflowExecutionInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ParentDomainID != nil {
		enc.AddString("parentDomainID", base64.StdEncoding.EncodeToString(v.ParentDomainID))
	}
	if v.ParentWorkflowID != nil {
		enc.AddString("parentWorkflowID", *v.ParentWorkflowID)
	}
	if v.ParentRunID != nil {
		enc.AddString("parentRunID", base64.StdEncoding.EncodeToString(v.ParentRunID))
	}
	if v.InitiatedID != nil {
		enc.AddInt64("initiatedID", *v.InitiatedID)
	}
	if v.CompletionEventBatchID != nil {
		enc.AddInt64("completionEventBatchID", *v.CompletionEventBatchID)
	}
	if v.CompletionEvent != nil {
		enc.AddString("completionEvent", base64.StdEncoding.EncodeToString(v.CompletionEvent))
	}
	if v.CompletionEventEncoding != nil {
		enc.AddString("completionEventEncoding", *v.CompletionEventEncoding)
	}
	if v.TaskList != nil {
		enc.AddString("taskList", *v.TaskList)
	}
	if v.WorkflowTypeName != nil {
		enc.AddString("workflowTypeName", *v.WorkflowTypeName)
	}
	if v.WorkflowTimeoutSeconds != nil {
		enc.AddInt32("workflowTimeoutSeconds", *v.WorkflowTimeoutSeconds)
	}
	if v.DecisionTaskTimeoutSeconds != nil {
		enc.AddInt32("decisionTaskTimeoutSeconds", *v.DecisionTaskTimeoutSeconds)
	}
	if v.ExecutionContext != nil {
		enc.AddString("executionContext", base64.StdEncoding.EncodeToString(v.ExecutionContext))
	}
	if v.State != nil {
		enc.AddInt32("state", *v.State)
	}
	if v.CloseStatus != nil {
		enc.AddInt32("closeStatus", *v.CloseStatus)
	}
	if v.StartVersion != nil {
		enc.AddInt64("startVersion", *v.StartVersion)
	}
	if v.LastWriteEventID != nil {
		enc.AddInt64("lastWriteEventID", *v.LastWriteEventID)
	}
	if v.LastEventTaskID != nil {
		enc.AddInt64("lastEventTaskID", *v.LastEventTaskID)
	}
	if v.LastFirstEventID != nil {
		enc.AddInt64("lastFirstEventID", *v.LastFirstEventID)
	}
	if v.LastProcessedEvent != nil {
		enc.AddInt64("lastProcessedEvent", *v.LastProcessedEvent)
	}
	if v.StartTimeNanos != nil {
		enc.AddInt64("startTimeNanos", *v.StartTimeNanos)
	}
	if v.LastUpdatedTimeNanos != nil {
		enc.AddInt64("lastUpdatedTimeNanos", *v.LastUpdatedTimeNanos)
	}
	if v.DecisionVersion != nil {
		enc.AddInt64("decisionVersion", *v.DecisionVersion)
	}
	if v.DecisionScheduleID != nil {
		enc.AddInt64("decisionScheduleID", *v.DecisionScheduleID)
	}
	if v.DecisionStartedID != nil {
		enc.AddInt64("decisionStartedID", *v.DecisionStartedID)
	}
	if v.DecisionTimeout != nil {
		enc.AddInt32("decisionTimeout", *v.DecisionTimeout)
	}
	if v.DecisionAttempt != nil {
		enc.AddInt64("decisionAttempt", *v.DecisionAttempt)
	}
	if v.DecisionStartedTimestampNanos != nil {
		enc.AddInt64("decisionStartedTimestampNanos", *v.DecisionStartedTimestampNanos)
	}
	if v.DecisionScheduledTimestampNanos != nil {
		enc.AddInt64("decisionScheduledTimestampNanos", *v.DecisionScheduledTimestampNanos)
	}
	if v.CancelRequested != nil {
		enc.AddBool("cancelRequested", *v.CancelRequested)
	}
	if v.DecisionOriginalScheduledTimestampNanos != nil {
		enc.AddInt64("decisionOriginalScheduledTimestampNanos", *v.DecisionOriginalScheduledTimestampNanos)
	}
	if v.CreateRequestID != nil {
		enc.AddString("createRequestID", *v.CreateRequestID)
	}
	if v.DecisionRequestID != nil {
		enc.AddString("decisionRequestID", *v.DecisionRequestID)
	}
	if v.CancelRequestID != nil {
		enc.AddString("cancelRequestID", *v.CancelRequestID)
	}
	if v.StickyTaskList != nil {
		enc.AddString("stickyTaskList", *v.StickyTaskList)
	}
	if v.StickyScheduleToStartTimeout != nil {
		enc.AddInt64("stickyScheduleToStartTimeout", *v.StickyScheduleToStartTimeout)
	}
	if v.RetryAttempt != nil {
		enc.AddInt64("retryAttempt", *v.RetryAttempt)
	}
	if v.RetryInitialIntervalSeconds != nil {
		enc.AddInt32("retryInitialIntervalSeconds", *v.RetryInitialIntervalSeconds)
	}
	if v.RetryMaximumIntervalSeconds != nil {
		enc.AddInt32("retryMaximumIntervalSeconds", *v.RetryMaximumIntervalSeconds)
	}
	if v.RetryMaximumAttempts != nil {
		enc.AddInt32("retryMaximumAttempts", *v.RetryMaximumAttempts)
	}
	if v.RetryExpirationSeconds != nil {
		enc.AddInt32("retryExpirationSeconds", *v.RetryExpirationSeconds)
	}
	if v.RetryBackoffCoefficient != nil {
		enc.AddFloat64("retryBackoffCoefficient", *v.RetryBackoffCoefficient)
	}
	if v.RetryExpirationTimeNanos != nil {
		enc.AddInt64("retryExpirationTimeNanos", *v.RetryExpirationTimeNanos)
	}
	if v.RetryNonRetryableErrors != nil {
		err = multierr.Append(err, enc.AddArray("retryNonRetryableErrors", (_List_String_Zapper)(v.RetryNonRetryableErrors)))
	}
	if v.HasRetryPolicy != nil {
		enc.AddBool("hasRetryPolicy", *v.HasRetryPolicy)
	}
	if v.CronSchedule != nil {
		enc.AddString("cronSchedule", *v.CronSchedule)
	}
	if v.EventStoreVersion != nil {
		enc.AddInt32("eventStoreVersion", *v.EventStoreVersion)
	}
	if v.EventBranchToken != nil {
		enc.AddString("eventBranchToken", base64.StdEncoding.EncodeToString(v.EventBranchToken))
	}
	if v.SignalCount != nil {
		enc.AddInt64("signalCount", *v.SignalCount)
	}
	if v.HistorySize != nil {
		enc.AddInt64("historySize", *v.HistorySize)
	}
	if v.ClientLibraryVersion != nil {
		enc.AddString("clientLibraryVersion", *v.ClientLibraryVersion)
	}
	if v.ClientFeatureVersion != nil {
		enc.AddString("clientFeatureVersion", *v.ClientFeatureVersion)
	}
	if v.ClientImpl != nil {
		enc.AddString("clientImpl", *v.ClientImpl)
	}
	if v.AutoResetPoints != nil {
		enc.AddString("autoResetPoints", base64.StdEncoding.EncodeToString(v.AutoResetPoints))
	}
	if v.AutoResetPointsEncoding != nil {
		enc.AddString("autoResetPointsEncoding", *v.AutoResetPointsEncoding)
	}
	if v.SearchAttributes != nil {
		err = multierr.Append(err, enc.AddObject("searchAttributes", (_Map_String_Binary_Zapper)(v.SearchAttributes)))
	}
	if v.Memo != nil {
		err = multierr.Append(err, enc.AddObject("memo", (_Map_String_Binary_Zapper)(v.Memo)))
	}
	if v.VersionHistories != nil {
		enc.AddString("versionHistories", base64.StdEncoding.EncodeToString(v.VersionHistories))
	}
	if v.VersionHistoriesEncoding != nil {
		enc.AddString("versionHistoriesEncoding", *v.VersionHistoriesEncoding)
	}
	if v.FirstExecutionRunID != nil {
		enc.AddString("firstExecutionRunID", base64.StdEncoding.EncodeToString(v.FirstExecutionRunID))
	}
	if v.PartitionConfig != nil {
		err = multierr.Append(err, enc.AddObject("partitionConfig", (_Map_String_String_Zapper)(v.PartitionConfig)))
	}
	if v.Checksum != nil {
		enc.AddString("checksum", base64.StdEncoding.EncodeToString(v.Checksum))
	}
	if v.ChecksumEncoding != nil {
		enc.AddString("checksumEncoding", *v.ChecksumEncoding)
	}
	return err
}

// GetParentDomainID returns the value of ParentDomainID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetParentDomainID() (o []byte) {
	if v != nil && v.ParentDomainID != nil {
		return v.ParentDomainID
	}

	return
}

// IsSetParentDomainID returns true if ParentDomainID is not nil.
func (v *WorkflowExecutionInfo) IsSetParentDomainID() bool {
	return v != nil && v.ParentDomainID != nil
}

// GetParentWorkflowID returns the value of ParentWorkflowID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetParentWorkflowID() (o string) {
	if v != nil && v.ParentWorkflowID != nil {
		return *v.ParentWorkflowID
	}

	return
}

// IsSetParentWorkflowID returns true if ParentWorkflowID is not nil.
func (v *WorkflowExecutionInfo) IsSetParentWorkflowID() bool {
	return v != nil && v.ParentWorkflowID != nil
}

// GetParentRunID returns the value of ParentRunID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetParentRunID() (o []byte) {
	if v != nil && v.ParentRunID != nil {
		return v.ParentRunID
	}

	return
}

// IsSetParentRunID returns true if ParentRunID is not nil.
func (v *WorkflowExecutionInfo) IsSetParentRunID() bool {
	return v != nil && v.ParentRunID != nil
}

// GetInitiatedID returns the value of InitiatedID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetInitiatedID() (o int64) {
	if v != nil && v.InitiatedID != nil {
		return *v.InitiatedID
	}

	return
}

// IsSetInitiatedID returns true if InitiatedID is not nil.
func (v *WorkflowExecutionInfo) IsSetInitiatedID() bool {
	return v != nil && v.InitiatedID != nil
}

// GetCompletionEventBatchID returns the value of CompletionEventBatchID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCompletionEventBatchID() (o int64) {
	if v != nil && v.CompletionEventBatchID != nil {
		return *v.CompletionEventBatchID
	}

	return
}

// IsSetCompletionEventBatchID returns true if CompletionEventBatchID is not nil.
func (v *WorkflowExecutionInfo) IsSetCompletionEventBatchID() bool {
	return v != nil && v.CompletionEventBatchID != nil
}

// GetCompletionEvent returns the value of CompletionEvent if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCompletionEvent() (o []byte) {
	if v != nil && v.CompletionEvent != nil {
		return v.CompletionEvent
	}

	return
}

// IsSetCompletionEvent returns true if CompletionEvent is not nil.
func (v *WorkflowExecutionInfo) IsSetCompletionEvent() bool {
	return v != nil && v.CompletionEvent != nil
}

// GetCompletionEventEncoding returns the value of CompletionEventEncoding if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCompletionEventEncoding() (o string) {
	if v != nil && v.CompletionEventEncoding != nil {
		return *v.CompletionEventEncoding
	}

	return
}

// IsSetCompletionEventEncoding returns true if CompletionEventEncoding is not nil.
func (v *WorkflowExecutionInfo) IsSetCompletionEventEncoding() bool {
	return v != nil && v.CompletionEventEncoding != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetTaskList() (o string) {
	if v != nil && v.TaskList != nil {
		return *v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *WorkflowExecutionInfo) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetWorkflowTypeName returns the value of WorkflowTypeName if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetWorkflowTypeName() (o string) {
	if v != nil && v.WorkflowTypeName != nil {
		return *v.WorkflowTypeName
	}

	return
}

// IsSetWorkflowTypeName returns true if WorkflowTypeName is not nil.
func (v *WorkflowExecutionInfo) IsSetWorkflowTypeName() bool {
	return v != nil && v.WorkflowTypeName != nil
}

// GetWorkflowTimeoutSeconds returns the value of WorkflowTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetWorkflowTimeoutSeconds() (o int32) {
	if v != nil && v.WorkflowTimeoutSeconds != nil {
		return *v.WorkflowTimeoutSeconds
	}

	return
}

// IsSetWorkflowTimeoutSeconds returns true if WorkflowTimeoutSeconds is not nil.
func (v *WorkflowExecutionInfo) IsSetWorkflowTimeoutSeconds() bool {
	return v != nil && v.WorkflowTimeoutSeconds != nil
}

// GetDecisionTaskTimeoutSeconds returns the value of DecisionTaskTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionTaskTimeoutSeconds() (o int32) {
	if v != nil && v.DecisionTaskTimeoutSeconds != nil {
		return *v.DecisionTaskTimeoutSeconds
	}

	return
}

// IsSetDecisionTaskTimeoutSeconds returns true if DecisionTaskTimeoutSeconds is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionTaskTimeoutSeconds() bool {
	return v != nil && v.DecisionTaskTimeoutSeconds != nil
}

// GetExecutionContext returns the value of ExecutionContext if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetExecutionContext() (o []byte) {
	if v != nil && v.ExecutionContext != nil {
		return v.ExecutionContext
	}

	return
}

// IsSetExecutionContext returns true if ExecutionContext is not nil.
func (v *WorkflowExecutionInfo) IsSetExecutionContext() bool {
	return v != nil && v.ExecutionContext != nil
}

// GetState returns the value of State if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetState() (o int32) {
	if v != nil && v.State != nil {
		return *v.State
	}

	return
}

// IsSetState returns true if State is not nil.
func (v *WorkflowExecutionInfo) IsSetState() bool {
	return v != nil && v.State != nil
}

// GetCloseStatus returns the value of CloseStatus if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCloseStatus() (o int32) {
	if v != nil && v.CloseStatus != nil {
		return *v.CloseStatus
	}

	return
}

// IsSetCloseStatus returns true if CloseStatus is not nil.
func (v *WorkflowExecutionInfo) IsSetCloseStatus() bool {
	return v != nil && v.CloseStatus != nil
}

// GetStartVersion returns the value of StartVersion if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetStartVersion() (o int64) {
	if v != nil && v.StartVersion != nil {
		return *v.StartVersion
	}

	return
}

// IsSetStartVersion returns true if StartVersion is not nil.
func (v *WorkflowExecutionInfo) IsSetStartVersion() bool {
	return v != nil && v.StartVersion != nil
}

// GetLastWriteEventID returns the value of LastWriteEventID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetLastWriteEventID() (o int64) {
	if v != nil && v.LastWriteEventID != nil {
		return *v.LastWriteEventID
	}

	return
}

// IsSetLastWriteEventID returns true if LastWriteEventID is not nil.
func (v *WorkflowExecutionInfo) IsSetLastWriteEventID() bool {
	return v != nil && v.LastWriteEventID != nil
}

// GetLastEventTaskID returns the value of LastEventTaskID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetLastEventTaskID() (o int64) {
	if v != nil && v.LastEventTaskID != nil {
		return *v.LastEventTaskID
	}

	return
}

// IsSetLastEventTaskID returns true if LastEventTaskID is not nil.
func (v *WorkflowExecutionInfo) IsSetLastEventTaskID() bool {
	return v != nil && v.LastEventTaskID != nil
}

// GetLastFirstEventID returns the value of LastFirstEventID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetLastFirstEventID() (o int64) {
	if v != nil && v.LastFirstEventID != nil {
		return *v.LastFirstEventID
	}

	return
}

// IsSetLastFirstEventID returns true if LastFirstEventID is not nil.
func (v *WorkflowExecutionInfo) IsSetLastFirstEventID() bool {
	return v != nil && v.LastFirstEventID != nil
}

// GetLastProcessedEvent returns the value of LastProcessedEvent if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetLastProcessedEvent() (o int64) {
	if v != nil && v.LastProcessedEvent != nil {
		return *v.LastProcessedEvent
	}

	return
}

// IsSetLastProcessedEvent returns true if LastProcessedEvent is not nil.
func (v *WorkflowExecutionInfo) IsSetLastProcessedEvent() bool {
	return v != nil && v.LastProcessedEvent != nil
}

// GetStartTimeNanos returns the value of StartTimeNanos if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetStartTimeNanos() (o int64) {
	if v != nil && v.StartTimeNanos != nil {
		return *v.StartTimeNanos
	}

	return
}

// IsSetStartTimeNanos returns true if StartTimeNanos is not nil.
func (v *WorkflowExecutionInfo) IsSetStartTimeNanos() bool {
	return v != nil && v.StartTimeNanos != nil
}

// GetLastUpdatedTimeNanos returns the value of LastUpdatedTimeNanos if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetLastUpdatedTimeNanos() (o int64) {
	if v != nil && v.LastUpdatedTimeNanos != nil {
		return *v.LastUpdatedTimeNanos
	}

	return
}

// IsSetLastUpdatedTimeNanos returns true if LastUpdatedTimeNanos is not nil.
func (v *WorkflowExecutionInfo) IsSetLastUpdatedTimeNanos() bool {
	return v != nil && v.LastUpdatedTimeNanos != nil
}

// GetDecisionVersion returns the value of DecisionVersion if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionVersion() (o int64) {
	if v != nil && v.DecisionVersion != nil {
		return *v.DecisionVersion
	}

	return
}

// IsSetDecisionVersion returns true if DecisionVersion is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionVersion() bool {
	return v != nil && v.DecisionVersion != nil
}

// GetDecisionScheduleID returns the value of DecisionScheduleID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionScheduleID() (o int64) {
	if v != nil && v.DecisionScheduleID != nil {
		return *v.DecisionScheduleID
	}

	return
}

// IsSetDecisionScheduleID returns true if DecisionScheduleID is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionScheduleID() bool {
	return v != nil && v.DecisionScheduleID != nil
}

// GetDecisionStartedID returns the value of DecisionStartedID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionStartedID() (o int64) {
	if v != nil && v.DecisionStartedID != nil {
		return *v.DecisionStartedID
	}

	return
}

// IsSetDecisionStartedID returns true if DecisionStartedID is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionStartedID() bool {
	return v != nil && v.DecisionStartedID != nil
}

// GetDecisionTimeout returns the value of DecisionTimeout if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionTimeout() (o int32) {
	if v != nil && v.DecisionTimeout != nil {
		return *v.DecisionTimeout
	}

	return
}

// IsSetDecisionTimeout returns true if DecisionTimeout is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionTimeout() bool {
	return v != nil && v.DecisionTimeout != nil
}

// GetDecisionAttempt returns the value of DecisionAttempt if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionAttempt() (o int64) {
	if v != nil && v.DecisionAttempt != nil {
		return *v.DecisionAttempt
	}

	return
}

// IsSetDecisionAttempt returns true if DecisionAttempt is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionAttempt() bool {
	return v != nil && v.DecisionAttempt != nil
}

// GetDecisionStartedTimestampNanos returns the value of DecisionStartedTimestampNanos if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionStartedTimestampNanos() (o int64) {
	if v != nil && v.DecisionStartedTimestampNanos != nil {
		return *v.DecisionStartedTimestampNanos
	}

	return
}

// IsSetDecisionStartedTimestampNanos returns true if DecisionStartedTimestampNanos is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionStartedTimestampNanos() bool {
	return v != nil && v.DecisionStartedTimestampNanos != nil
}

// GetDecisionScheduledTimestampNanos returns the value of DecisionScheduledTimestampNanos if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionScheduledTimestampNanos() (o int64) {
	if v != nil && v.DecisionScheduledTimestampNanos != nil {
		return *v.DecisionScheduledTimestampNanos
	}

	return
}

// IsSetDecisionScheduledTimestampNanos returns true if DecisionScheduledTimestampNanos is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionScheduledTimestampNanos() bool {
	return v != nil && v.DecisionScheduledTimestampNanos != nil
}

// GetCancelRequested returns the value of CancelRequested if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCancelRequested() (o bool) {
	if v != nil && v.CancelRequested != nil {
		return *v.CancelRequested
	}

	return
}

// IsSetCancelRequested returns true if CancelRequested is not nil.
func (v *WorkflowExecutionInfo) IsSetCancelRequested() bool {
	return v != nil && v.CancelRequested != nil
}

// GetDecisionOriginalScheduledTimestampNanos returns the value of DecisionOriginalScheduledTimestampNanos if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionOriginalScheduledTimestampNanos() (o int64) {
	if v != nil && v.DecisionOriginalScheduledTimestampNanos != nil {
		return *v.DecisionOriginalScheduledTimestampNanos
	}

	return
}

// IsSetDecisionOriginalScheduledTimestampNanos returns true if DecisionOriginalScheduledTimestampNanos is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionOriginalScheduledTimestampNanos() bool {
	return v != nil && v.DecisionOriginalScheduledTimestampNanos != nil
}

// GetCreateRequestID returns the value of CreateRequestID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCreateRequestID() (o string) {
	if v != nil && v.CreateRequestID != nil {
		return *v.CreateRequestID
	}

	return
}

// IsSetCreateRequestID returns true if CreateRequestID is not nil.
func (v *WorkflowExecutionInfo) IsSetCreateRequestID() bool {
	return v != nil && v.CreateRequestID != nil
}

// GetDecisionRequestID returns the value of DecisionRequestID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetDecisionRequestID() (o string) {
	if v != nil && v.DecisionRequestID != nil {
		return *v.DecisionRequestID
	}

	return
}

// IsSetDecisionRequestID returns true if DecisionRequestID is not nil.
func (v *WorkflowExecutionInfo) IsSetDecisionRequestID() bool {
	return v != nil && v.DecisionRequestID != nil
}

// GetCancelRequestID returns the value of CancelRequestID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCancelRequestID() (o string) {
	if v != nil && v.CancelRequestID != nil {
		return *v.CancelRequestID
	}

	return
}

// IsSetCancelRequestID returns true if CancelRequestID is not nil.
func (v *WorkflowExecutionInfo) IsSetCancelRequestID() bool {
	return v != nil && v.CancelRequestID != nil
}

// GetStickyTaskList returns the value of StickyTaskList if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetStickyTaskList() (o string) {
	if v != nil && v.StickyTaskList != nil {
		return *v.StickyTaskList
	}

	return
}

// IsSetStickyTaskList returns true if StickyTaskList is not nil.
func (v *WorkflowExecutionInfo) IsSetStickyTaskList() bool {
	return v != nil && v.StickyTaskList != nil
}

// GetStickyScheduleToStartTimeout returns the value of StickyScheduleToStartTimeout if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetStickyScheduleToStartTimeout() (o int64) {
	if v != nil && v.StickyScheduleToStartTimeout != nil {
		return *v.StickyScheduleToStartTimeout
	}

	return
}

// IsSetStickyScheduleToStartTimeout returns true if StickyScheduleToStartTimeout is not nil.
func (v *WorkflowExecutionInfo) IsSetStickyScheduleToStartTimeout() bool {
	return v != nil && v.StickyScheduleToStartTimeout != nil
}

// GetRetryAttempt returns the value of RetryAttempt if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryAttempt() (o int64) {
	if v != nil && v.RetryAttempt != nil {
		return *v.RetryAttempt
	}

	return
}

// IsSetRetryAttempt returns true if RetryAttempt is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryAttempt() bool {
	return v != nil && v.RetryAttempt != nil
}

// GetRetryInitialIntervalSeconds returns the value of RetryInitialIntervalSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryInitialIntervalSeconds() (o int32) {
	if v != nil && v.RetryInitialIntervalSeconds != nil {
		return *v.RetryInitialIntervalSeconds
	}

	return
}

// IsSetRetryInitialIntervalSeconds returns true if RetryInitialIntervalSeconds is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryInitialIntervalSeconds() bool {
	return v != nil && v.RetryInitialIntervalSeconds != nil
}

// GetRetryMaximumIntervalSeconds returns the value of RetryMaximumIntervalSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryMaximumIntervalSeconds() (o int32) {
	if v != nil && v.RetryMaximumIntervalSeconds != nil {
		return *v.RetryMaximumIntervalSeconds
	}

	return
}

// IsSetRetryMaximumIntervalSeconds returns true if RetryMaximumIntervalSeconds is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryMaximumIntervalSeconds() bool {
	return v != nil && v.RetryMaximumIntervalSeconds != nil
}

// GetRetryMaximumAttempts returns the value of RetryMaximumAttempts if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryMaximumAttempts() (o int32) {
	if v != nil && v.RetryMaximumAttempts != nil {
		return *v.RetryMaximumAttempts
	}

	return
}

// IsSetRetryMaximumAttempts returns true if RetryMaximumAttempts is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryMaximumAttempts() bool {
	return v != nil && v.RetryMaximumAttempts != nil
}

// GetRetryExpirationSeconds returns the value of RetryExpirationSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryExpirationSeconds() (o int32) {
	if v != nil && v.RetryExpirationSeconds != nil {
		return *v.RetryExpirationSeconds
	}

	return
}

// IsSetRetryExpirationSeconds returns true if RetryExpirationSeconds is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryExpirationSeconds() bool {
	return v != nil && v.RetryExpirationSeconds != nil
}

// GetRetryBackoffCoefficient returns the value of RetryBackoffCoefficient if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryBackoffCoefficient() (o float64) {
	if v != nil && v.RetryBackoffCoefficient != nil {
		return *v.RetryBackoffCoefficient
	}

	return
}

// IsSetRetryBackoffCoefficient returns true if RetryBackoffCoefficient is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryBackoffCoefficient() bool {
	return v != nil && v.RetryBackoffCoefficient != nil
}

// GetRetryExpirationTimeNanos returns the value of RetryExpirationTimeNanos if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryExpirationTimeNanos() (o int64) {
	if v != nil && v.RetryExpirationTimeNanos != nil {
		return *v.RetryExpirationTimeNanos
	}

	return
}

// IsSetRetryExpirationTimeNanos returns true if RetryExpirationTimeNanos is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryExpirationTimeNanos() bool {
	return v != nil && v.RetryExpirationTimeNanos != nil
}

// GetRetryNonRetryableErrors returns the value of RetryNonRetryableErrors if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetRetryNonRetryableErrors() (o []string) {
	if v != nil && v.RetryNonRetryableErrors != nil {
		return v.RetryNonRetryableErrors
	}

	return
}

// IsSetRetryNonRetryableErrors returns true if RetryNonRetryableErrors is not nil.
func (v *WorkflowExecutionInfo) IsSetRetryNonRetryableErrors() bool {
	return v != nil && v.RetryNonRetryableErrors != nil
}

// GetHasRetryPolicy returns the value of HasRetryPolicy if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetHasRetryPolicy() (o bool) {
	if v != nil && v.HasRetryPolicy != nil {
		return *v.HasRetryPolicy
	}

	return
}

// IsSetHasRetryPolicy returns true if HasRetryPolicy is not nil.
func (v *WorkflowExecutionInfo) IsSetHasRetryPolicy() bool {
	return v != nil && v.HasRetryPolicy != nil
}

// GetCronSchedule returns the value of CronSchedule if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetCronSchedule() (o string) {
	if v != nil && v.CronSchedule != nil {
		return *v.CronSchedule
	}

	return
}

// IsSetCronSchedule returns true if CronSchedule is not nil.
func (v *WorkflowExecutionInfo) IsSetCronSchedule() bool {
	return v != nil && v.CronSchedule != nil
}

// GetEventStoreVersion returns the value of EventStoreVersion if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetEventStoreVersion() (o int32) {
	if v != nil && v.EventStoreVersion != nil {
		return *v.EventStoreVersion
	}

	return
}

// IsSetEventStoreVersion returns true if EventStoreVersion is not nil.
func (v *WorkflowExecutionInfo) IsSetEventStoreVersion() bool {
	return v != nil && v.EventStoreVersion != nil
}

// GetEventBranchToken returns the value of EventBranchToken if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetEventBranchToken() (o []byte) {
	if v != nil && v.EventBranchToken != nil {
		return v.EventBranchToken
	}

	return
}

// IsSetEventBranchToken returns true if EventBranchToken is not nil.
func (v *WorkflowExecutionInfo) IsSetEventBranchToken() bool {
	return v != nil && v.EventBranchToken != nil
}

// GetSignalCount returns the value of SignalCount if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetSignalCount() (o int64) {
	if v != nil && v.SignalCount != nil {
		return *v.SignalCount
	}

	return
}

// IsSetSignalCount returns true if SignalCount is not nil.
func (v *WorkflowExecutionInfo) IsSetSignalCount() bool {
	return v != nil && v.SignalCount != nil
}

// GetHistorySize returns the value of HistorySize if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetHistorySize() (o int64) {
	if v != nil && v.HistorySize != nil {
		return *v.HistorySize
	}

	return
}

// IsSetHistorySize returns true if HistorySize is not nil.
func (v *WorkflowExecutionInfo) IsSetHistorySize() bool {
	return v != nil && v.HistorySize != nil
}

// GetClientLibraryVersion returns the value of ClientLibraryVersion if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetClientLibraryVersion() (o string) {
	if v != nil && v.ClientLibraryVersion != nil {
		return *v.ClientLibraryVersion
	}

	return
}

// IsSetClientLibraryVersion returns true if ClientLibraryVersion is not nil.
func (v *WorkflowExecutionInfo) IsSetClientLibraryVersion() bool {
	return v != nil && v.ClientLibraryVersion != nil
}

// GetClientFeatureVersion returns the value of ClientFeatureVersion if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetClientFeatureVersion() (o string) {
	if v != nil && v.ClientFeatureVersion != nil {
		return *v.ClientFeatureVersion
	}

	return
}

// IsSetClientFeatureVersion returns true if ClientFeatureVersion is not nil.
func (v *WorkflowExecutionInfo) IsSetClientFeatureVersion() bool {
	return v != nil && v.ClientFeatureVersion != nil
}

// GetClientImpl returns the value of ClientImpl if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetClientImpl() (o string) {
	if v != nil && v.ClientImpl != nil {
		return *v.ClientImpl
	}

	return
}

// IsSetClientImpl returns true if ClientImpl is not nil.
func (v *WorkflowExecutionInfo) IsSetClientImpl() bool {
	return v != nil && v.ClientImpl != nil
}

// GetAutoResetPoints returns the value of AutoResetPoints if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetAutoResetPoints() (o []byte) {
	if v != nil && v.AutoResetPoints != nil {
		return v.AutoResetPoints
	}

	return
}

// IsSetAutoResetPoints returns true if AutoResetPoints is not nil.
func (v *WorkflowExecutionInfo) IsSetAutoResetPoints() bool {
	return v != nil && v.AutoResetPoints != nil
}

// GetAutoResetPointsEncoding returns the value of AutoResetPointsEncoding if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetAutoResetPointsEncoding() (o string) {
	if v != nil && v.AutoResetPointsEncoding != nil {
		return *v.AutoResetPointsEncoding
	}

	return
}

// IsSetAutoResetPointsEncoding returns true if AutoResetPointsEncoding is not nil.
func (v *WorkflowExecutionInfo) IsSetAutoResetPointsEncoding() bool {
	return v != nil && v.AutoResetPointsEncoding != nil
}

// GetSearchAttributes returns the value of SearchAttributes if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetSearchAttributes() (o map[string][]byte) {
	if v != nil && v.SearchAttributes != nil {
		return v.SearchAttributes
	}

	return
}

// IsSetSearchAttributes returns true if SearchAttributes is not nil.
func (v *WorkflowExecutionInfo) IsSetSearchAttributes() bool {
	return v != nil && v.SearchAttributes != nil
}

// GetMemo returns the value of Memo if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetMemo() (o map[string][]byte) {
	if v != nil && v.Memo != nil {
		return v.Memo
	}

	return
}

// IsSetMemo returns true if Memo is not nil.
func (v *WorkflowExecutionInfo) IsSetMemo() bool {
	return v != nil && v.Memo != nil
}

// GetVersionHistories returns the value of VersionHistories if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetVersionHistories() (o []byte) {
	if v != nil && v.VersionHistories != nil {
		return v.VersionHistories
	}

	return
}

// IsSetVersionHistories returns true if VersionHistories is not nil.
func (v *WorkflowExecutionInfo) IsSetVersionHistories() bool {
	return v != nil && v.VersionHistories != nil
}

// GetVersionHistoriesEncoding returns the value of VersionHistoriesEncoding if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetVersionHistoriesEncoding() (o string) {
	if v != nil && v.VersionHistoriesEncoding != nil {
		return *v.VersionHistoriesEncoding
	}

	return
}

// IsSetVersionHistoriesEncoding returns true if VersionHistoriesEncoding is not nil.
func (v *WorkflowExecutionInfo) IsSetVersionHistoriesEncoding() bool {
	return v != nil && v.VersionHistoriesEncoding != nil
}

// GetFirstExecutionRunID returns the value of FirstExecutionRunID if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetFirstExecutionRunID() (o []byte) {
	if v != nil && v.FirstExecutionRunID != nil {
		return v.FirstExecutionRunID
	}

	return
}

// IsSetFirstExecutionRunID returns true if FirstExecutionRunID is not nil.
func (v *WorkflowExecutionInfo) IsSetFirstExecutionRunID() bool {
	return v != nil && v.FirstExecutionRunID != nil
}

// GetPartitionConfig returns the value of PartitionConfig if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetPartitionConfig() (o map[string]string) {
	if v != nil && v.PartitionConfig != nil {
		return v.PartitionConfig
	}

	return
}

// IsSetPartitionConfig returns true if PartitionConfig is not nil.
func (v *WorkflowExecutionInfo) IsSetPartitionConfig() bool {
	return v != nil && v.PartitionConfig != nil
}

// GetChecksum returns the value of Checksum if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetChecksum() (o []byte) {
	if v != nil && v.Checksum != nil {
		return v.Checksum
	}

	return
}

// IsSetChecksum returns true if Checksum is not nil.
func (v *WorkflowExecutionInfo) IsSetChecksum() bool {
	return v != nil && v.Checksum != nil
}

// GetChecksumEncoding returns the value of ChecksumEncoding if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionInfo) GetChecksumEncoding() (o string) {
	if v != nil && v.ChecksumEncoding != nil {
		return *v.ChecksumEncoding
	}

	return
}

// IsSetChecksumEncoding returns true if ChecksumEncoding is not nil.
func (v *WorkflowExecutionInfo) IsSetChecksumEncoding() bool {
	return v != nil && v.ChecksumEncoding != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "sqlblobs",
	Package:  "github.com/uber/cadence/.gen/go/sqlblobs",
	FilePath: "sqlblobs.thrift",
	SHA1:     "956cdeaa8460d9fb5b252e4cbef6edd6e097c1f7",
	Includes: []*thriftreflect.ThriftModule{
		shared.ThriftModule,
	},
	Raw: rawIDL,
}

const rawIDL = "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nnamespace java com.uber.cadence.sqlblobs\n\ninclude \"shared.thrift\"\n\nstruct ShardInfo {\n  10: optional i32 stolenSinceRenew\n  12: optional i64 (js.type = \"Long\") updatedAtNanos\n  14: optional i64 (js.type = \"Long\") replicationAckLevel\n  16: optional i64 (js.type = \"Long\") transferAckLevel\n  18: optional i64 (js.type = \"Long\") timerAckLevelNanos\n  24: optional i64 (js.type = \"Long\") domainNotificationVersion\n  34: optional map<string, i64> clusterTransferAckLevel\n  36: optional map<string, i64> clusterTimerAckLevel\n  38: optional string owner\n  40: optional map<string, i64> clusterReplicationLevel\n  42: optional binary pendingFailoverMarkers\n  44: optional string pendingFailoverMarkersEncoding\n  46: optional map<string, i64> replicationDlqAckLevel\n  50: optional binary transferProcessingQueueStates\n  51: optional string transferProcessingQueueStatesEncoding\n  55: optional binary timerProcessingQueueStates\n  56: optional string timerProcessingQueueStatesEncoding\n  60: optional binary crossClusterProcessingQueueStates\n  61: optional string crossClusterProcessingQueueStatesEncoding\n  64: optional map<i32, shared.QueueState> queueStates\n}\n\nstruct DomainInfo {\n  10: optional string name\n  12: optional string description\n  14: optional string owner\n  16: optional i32 status\n  18: optional i16 retentionDays\n  20: optional bool emitMetric\n  22: optional string archivalBucket\n  24: optional i16 archivalStatus\n  26: optional i64 (js.type = \"Long\") configVersion\n  28: optional i64 (js.type = \"Long\") notificationVersion\n  30: optional i64 (js.type = \"Long\") failoverNotificationVersion\n  32: optional i64 (js.type = \"Long\") failoverVersion\n  34: optional string activeClusterName\n  36: optional list<string> clusters\n  38: optional map<string, string> data\n  39: optional binary badBinaries\n  40: optional string badBinariesEncoding\n  42: optional i16 historyArchivalStatus\n  44: optional string historyArchivalURI\n  46: optional i16 visibilityArchivalStatus\n  48: optional string visibilityArchivalURI\n  50: optional i64 (js.type = \"Long\") failoverEndTime\n  52: optional i64 (js.type = \"Long\") previousFailoverVersion\n  54: optional i64 (js.type = \"Long\") lastUpdatedTime\n  56: optional binary isolationGroupsConfiguration\n  58: optional string isolationGroupsConfigurationEncoding\n  60: optional binary asyncWorkflowConfiguration\n  62: optional string asyncWorkflowConfigurationEncoding\n}\n\nstruct HistoryTreeInfo {\n  10: optional i64 (js.type = \"Long\") createdTimeNanos // For fork operation to prevent race condition of leaking event data when forking branches fail. Also can be used for clean up leaked data\n  12: optional list<shared.HistoryBranchRange> ancestors\n  14: optional string info // For lookup back to workflow during debugging, also background cleanup when fork operation cannot finish self cleanup due to crash.\n}\n\nstruct WorkflowExecutionInfo {\n  10: optional binary parentDomainID\n  12: optional string parentWorkflowID\n  14: optional binary parentRunID\n  16: optional i64 (js.type = \"Long\") initiatedID\n  18: optional i64 (js.type = \"Long\") completionEventBatchID\n  20: optional binary completionEvent\n  22: optional string completionEventEncoding\n  24: optional string taskList\n  26: optional string workflowTypeName\n  28: optional i32 workflowTimeoutSeconds\n  30: optional i32 decisionTaskTimeoutSeconds\n  32: optional binary executionContext\n  34: optional i32 state\n  36: optional i32 closeStatus\n  38: optional i64 (js.type = \"Long\") startVersion\n  44: optional i64 (js.type = \"Long\") lastWriteEventID\n  48: optional i64 (js.type = \"Long\") lastEventTaskID\n  50: optional i64 (js.type = \"Long\") lastFirstEventID\n  52: optional i64 (js.type = \"Long\") lastProcessedEvent\n  54: optional i64 (js.type = \"Long\") startTimeNanos\n  56: optional i64 (js.type = \"Long\") lastUpdatedTimeNanos\n  58: optional i64 (js.type = \"Long\") decisionVersion\n  60: optional i64 (js.type = \"Long\") decisionScheduleID\n  62: optional i64 (js.type = \"Long\") decisionStartedID\n  64: optional i32 decisionTimeout\n  66: optional i64 (js.type = \"Long\") decisionAttempt\n  68: optional i64 (js.type = \"Long\") decisionStartedTimestampNanos\n  69: optional i64 (js.type = \"Long\") decisionScheduledTimestampNanos\n  70: optional bool cancelRequested\n  71: optional i64 (js.type = \"Long\") decisionOriginalScheduledTimestampNanos\n  72: optional string createRequestID\n  74: optional string decisionRequestID\n  76: optional string cancelRequestID\n  78: optional string stickyTaskList\n  80: optional i64 (js.type = \"Long\") stickyScheduleToStartTimeout\n  82: optional i64 (js.type = \"Long\") retryAttempt\n  84: optional i32 retryInitialIntervalSeconds\n  86: optional i32 retryMaximumIntervalSeconds\n  88: optional i32 retryMaximumAttempts\n  90: optional i32 retryExpirationSeconds\n  92: optional double retryBackoffCoefficient\n  94: optional i64 (js.type = \"Long\") retryExpirationTimeNanos\n  96: optional list<string> retryNonRetryableErrors\n  98: optional bool hasRetryPolicy\n  100: optional string cronSchedule\n  102: optional i32 eventStoreVersion\n  104: optional binary eventBranchToken\n  106: optional i64 (js.type = \"Long\") signalCount\n  108: optional i64 (js.type = \"Long\") historySize\n  110: optional string clientLibraryVersion\n  112: optional string clientFeatureVersion\n  114: optional string clientImpl\n  115: optional binary autoResetPoints\n  116: optional string autoResetPointsEncoding\n  118: optional map<string, binary> searchAttributes\n  120: optional map<string, binary> memo\n  122: optional binary versionHistories\n  124: optional string versionHistoriesEncoding\n  126: optional binary firstExecutionRunID\n  128: optional map<string, string> partitionConfig\n  130: optional binary checksum\n  132: optional string checksumEncoding\n}\n\nstruct ActivityInfo {\n  10: optional i64 (js.type = \"Long\") version\n  12: optional i64 (js.type = \"Long\") scheduledEventBatchID\n  14: optional binary scheduledEvent\n  16: optional string scheduledEventEncoding\n  18: optional i64 (js.type = \"Long\") scheduledTimeNanos\n  20: optional i64 (js.type = \"Long\") startedID\n  22: optional binary startedEvent\n  24: optional string startedEventEncoding\n  26: optional i64 (js.type = \"Long\") startedTimeNanos\n  28: optional string activityID\n  30: optional string requestID\n  32: optional i32 scheduleToStartTimeoutSeconds\n  34: optional i32 scheduleToCloseTimeoutSeconds\n  36: optional i32 startToCloseTimeoutSeconds\n  38: optional i32 heartbeatTimeoutSeconds\n  40: optional bool cancelRequested\n  42: optional i64 (js.type = \"Long\") cancelRequestID\n  44: optional i32 timerTaskStatus\n  46: optional i32 attempt\n  48: optional string taskList\n  50: optional string startedIdentity\n  52: optional bool hasRetryPolicy\n  54: optional i32 retryInitialIntervalSeconds\n  56: optional i32 retryMaximumIntervalSeconds\n  58: optional i32 retryMaximumAttempts\n  60: optional i64 (js.type = \"Long\") retryExpirationTimeNanos\n  62: optional double retryBackoffCoefficient\n  64: optional list<string> retryNonRetryableErrors\n  66: optional string retryLastFailureReason\n  68: optional string retryLastWorkerIdentity\n  70: optional binary retryLastFailureDetails\n}\n\nstruct ChildExecutionInfo {\n  10: optional i64 (js.type = \"Long\") version\n  12: optional i64 (js.type = \"Long\") initiatedEventBatchID\n  14: optional i64 (js.type = \"Long\") startedID\n  16: optional binary initiatedEvent\n  18: optional string initiatedEventEncoding\n  20: optional string startedWorkflowID\n  22: optional binary startedRunID\n  24: optional binary startedEvent\n  26: optional string startedEventEncoding\n  28: optional string createRequestID\n  29: optional string domainID\n  30: optional string domainName // deprecated\n  32: optional string workflowTypeName\n  35: optional i32 parentClosePolicy\n}\n\nstruct SignalInfo {\n  10: optional i64 (js.type = \"Long\") version\n  11: optional i64 (js.type = \"Long\") initiatedEventBatchID\n  12: optional string requestID\n  14: optional string name\n  16: optional binary input\n  18: optional binary control\n}\n\nstruct RequestCancelInfo {\n  10: optional i64 (js.type = \"Long\") version\n  11: optional i64 (js.type = \"Long\") initiatedEventBatchID\n  12: optional string cancelRequestID\n}\n\nstruct TimerInfo {\n  10: optional i64 (js.type = \"Long\") version\n  12: optional i64 (js.type = \"Long\") startedID\n  14: optional i64 (js.type = \"Long\") expiryTimeNanos\n  // TaskID is a misleading variable, it actually serves\n  // the purpose of indicating whether a timer task is\n  // generated for this timer info\n  16: optional i64 (js.type = \"Long\") taskID\n}\n\nstruct TaskInfo {\n  10: optional string workflowID\n  12: optional binary runID\n  13: optional i64 (js.type = \"Long\") scheduleID\n  14: optional i64 (js.type = \"Long\") expiryTimeNanos\n  15: optional i64 (js.type = \"Long\") createdTimeNanos\n  17: optional map<string, string> partitionConfig\n}\n\nstruct TaskListPartition {\n    10: optional list<string> isolationGroups\n}\n\nstruct TaskListPartitionConfig {\n  10: optional i64 (js.type = \"Long\") version\n  12: optional i32 numReadPartitions\n  14: optional i32 numWritePartitions\n  16: optional map<i32, TaskListPartition> readPartitions\n  18: optional map<i32, TaskListPartition> writePartitions\n}\n\nstruct TaskListInfo {\n  10: optional i16 kind // {Normal, Sticky}\n  12: optional i64 (js.type = \"Long\") ackLevel\n  14: optional i64 (js.type = \"Long\") expiryTimeNanos\n  16: optional i64 (js.type = \"Long\") lastUpdatedNanos\n  18: optional TaskListPartitionConfig adaptivePartitionConfig\n}\n\nstruct TransferTaskInfo {\n  10: optional binary domainID\n  12: optional string workflowID\n  14: optional binary runID\n  16: optional i16 taskType\n  18: optional binary targetDomainID\n  20: optional string targetWorkflowID\n  22: optional binary targetRunID\n  24: optional string taskList\n  26: optional bool targetChildWorkflowOnly\n  28: optional i64 (js.type = \"Long\") scheduleID\n  30: optional i64 (js.type = \"Long\") version\n  32: optional i64 (js.type = \"Long\") visibilityTimestampNanos\n  34: optional set<binary> targetDomainIDs\n}\n\nstruct TimerTaskInfo {\n  10: optional binary domainID\n  12: optional string workflowID\n  14: optional binary runID\n  16: optional i16 taskType\n  18: optional i16 timeoutType\n  20: optional i64 (js.type = \"Long\") version\n  22: optional i64 (js.type = \"Long\") scheduleAttempt\n  24: optional i64 (js.type = \"Long\") eventID\n}\n\nstruct ReplicationTaskInfo {\n  10: optional binary domainID\n  12: optional string workflowID\n  14: optional binary runID\n  16: optional i16 taskType\n  18: optional i64 (js.type = \"Long\") version\n  20: optional i64 (js.type = \"Long\") firstEventID\n  22: optional i64 (js.type = \"Long\") nextEventID\n  24: optional i64 (js.type = \"Long\") scheduledID\n  26: optional i32 eventStoreVersion\n  28: optional i32 newRunEventStoreVersion\n  30: optional binary branch_token\n  34: optional binary newRunBranchToken\n  38: optional i64 (js.type = \"Long\") creationTime\n}\n\nenum AsyncRequestType {\n  StartWorkflowExecutionAsyncRequest\n  SignalWithStartWorkflowExecutionAsyncRequest\n}\n\nstruct AsyncRequestMessage {\n  10: optional string partitionKey\n  12: optional AsyncRequestType type\n  14: optional shared.Header header\n  16: optional string encoding\n  18: optional binary payload\n}\n"
